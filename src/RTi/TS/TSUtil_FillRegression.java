package RTi.TS;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;

import RTi.Util.Math.DataTransformationType;
import RTi.Util.Math.NumberOfEquationsType;
import RTi.Util.Math.RegressionChecks;
import RTi.Util.Math.RegressionData;
import RTi.Util.Math.RegressionEstimateErrors;
import RTi.Util.Math.RegressionFilledValues;
import RTi.Util.Math.RegressionResults;
import RTi.Util.Math.RegressionType;
import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;
import RTi.Util.Table.DataTable;
import RTi.Util.Table.TableField;
import RTi.Util.Table.TableRecord;
import RTi.Util.Time.DateTime;
import RTi.Util.Time.TimeUtil;

/**
Helper class to help with FillRegression and FillMOVE2 commands.
*/
public class TSUtil_FillRegression
{
    
/**
Independent time series.
*/
private TS __tsIndependent = null;

/**
Time series being filled.
*/
private TS __tsToFill = null;

/**
Analysis method (regression type).
*/
private RegressionType __analysisMethod = RegressionType.OLS_REGRESSION; // Default

/**
Indicates whether to fill with one equation or monthly equations.
*/
private NumberOfEquationsType __numberOfEquations = null;

/**
List of month numbers to analyze when using one equation, where each month is 1-12 (Jan - Dec),
or null to analyze all months.
*/
private int [] __analysisMonths = null;

/**
Indicates the data transformation.
*/
private DataTransformationType __transformation = null;

/**
Data value to substitute for the original when using a log transform and the original value is <= 0.
Can be any number > 0.
TODO SAM 2010-12-17 Allow NaN to throw the number away, but this changes counts, etc.
*/
private Double __leZeroLogValue = new Double(TSRegressionAnalysis.getLEZeroLogValueDefault()); // Default

/**
The intercept to force, or null if not forcing.  If set, only zero is allowed and it is only used with
OLS regression.
*/
private Double __forcedIntercept = null;

/**
Analysis period start for the dependent (Y) time series.
*/
private DateTime __dependentAnalysisStart = null;

/**
Analysis period end for the dependent (Y) time series.
*/
private DateTime __dependentAnalysisEnd = null;

/**
Analysis period start for the independent (X) time series.  For OLS and MOVE2,
this is the same as the dependent analysis period.  For MOVE2 it can be different.
*/
private DateTime __independentAnalysisStart = null;

/**
Analysis period end for the independent (X) time series.  For OLS and MOVE2,
this is the same as the dependent analysis period.  For MOVE2 it can be different.
*/
private DateTime __independentAnalysisEnd = null;

/**
Minimum sample size needed for a good relationship.
*/
private Integer __minimumSampleSize = null;

/**
Minimum R needed for a good relationship;
*/
private Double __minimumR = null;

/**
Confidence interval that must be met for good relationship.
*/
private Double __confidenceIntervalPercent = null;

/**
Start of filling.
*/
private DateTime __fillStart;

/**
End of filling.
*/
private DateTime __fillEnd;

/**
Flag to mark filled values.
*/
private String __fillFlag = null;

/**
Fill flag description.
*/
private String __fillFlagDesc = null;

/**
Whether to actually do the filling (or just compute the relationships).
*/
private boolean __doFill = true;

/**
Description string to append to time series description, rather than using default.
*/
private String __descriptionString = null;

/**
The TSRegressionAnalysis object that performs the analysis.
*/
private TSRegressionAnalysis __tsRegressionAnalysis = null;

/**
The TSRegressionFilledValues object that contains information about filled values.
*/
private TSRegressionFilledValues __tsRegressionFilledValues = null;
    
/**
List of runtime errors generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new Vector();
    
/**
Constructor.
*/
public TSUtil_FillRegression ( TS tsToFill, TS tsIndependent,
        // TSRegression tsRegression, // TODO SAM 2012-01-15 Evaluate if should support previous data
        RegressionType analysisMethod,
        NumberOfEquationsType numberOfEquations, int [] analysisMonths,
        DataTransformationType transformation, Double leZeroLogValue, Double forcedIntercept,
        DateTime dependentAnalysisStart, DateTime dependentAnalysisEnd,
        DateTime independentAnalysisStart, DateTime independentAnalysisEnd,
        Integer minimumSampleSize, Double minimumR, Double confidenceInterval,
        DateTime fillStart, DateTime fillEnd,
        String fillFlag, String fillFlagDesc, boolean doFill,
        String descriptionString )
{
    // Time series to fill
    if ( tsToFill == null ) {
        throw new IllegalArgumentException( "Null time series to fill." );
    }
    else {
        __tsToFill = tsToFill;
    }
    // Independent time series
    if ( tsIndependent == null ) {
        throw new IllegalArgumentException( "Null independent time series." );
    }
    else {
        __tsIndependent = tsIndependent;
    }
    if ( !TSUtil.intervalsMatch(tsToFill,tsIndependent) ) {
        throw new UnequalTimeIntervalException ( "Dependent and independent time series have different data intevals." );
    }
    // Analysis method
    if ( analysisMethod == null ) {
        analysisMethod = RegressionType.OLS_REGRESSION;
    }
    __analysisMethod = analysisMethod;
    // Number of equations
    if ( numberOfEquations == null ) {
        numberOfEquations = NumberOfEquationsType.ONE_EQUATION;
    }
    __numberOfEquations = numberOfEquations;
    // Months to analyze
    __analysisMonths = analysisMonths;
    // Transformation
    if ( transformation == null ) {
        transformation = DataTransformationType.NONE;
    }
    __transformation = transformation;
    // Value to use for <=0 when log transform
    if ( leZeroLogValue != null ) {
        __leZeroLogValue = leZeroLogValue;
    }
    // Forced intercept (can only be non-null for no transform and in this case must be zero).
    if ( (__forcedIntercept != null) && (__forcedIntercept != 0.0) ) {
        throw new IllegalArgumentException ( "Intercept (" + __forcedIntercept + ") can only be specified as zero." );
    }
    // Dependent analysis period
    // If dates are null, get from the time series
    if ( dependentAnalysisStart == null ) {
        __dependentAnalysisStart = new DateTime(__tsToFill.getDate1());
    }
    else {
        __dependentAnalysisStart = new DateTime(dependentAnalysisStart);
    }
    if ( dependentAnalysisEnd == null ) {
        __dependentAnalysisEnd = new DateTime(__tsToFill.getDate2());
    }
    else {
        __dependentAnalysisEnd = new DateTime(dependentAnalysisEnd);
    }
    // Independent analysis period...
    if ( __analysisMethod == RegressionType.OLS_REGRESSION ) {
        // Independent analysis period is the same as the dependent...
        __independentAnalysisStart = new DateTime(__dependentAnalysisStart);
        __independentAnalysisEnd = new DateTime(__dependentAnalysisEnd);
    }
    else if ( __analysisMethod == RegressionType.MOVE2 ) {
        if ( independentAnalysisStart == null ) {
            __independentAnalysisStart = new DateTime(__tsIndependent.getDate1());
        }
        else {
            __independentAnalysisStart = new DateTime(independentAnalysisStart);
        }

        if ( independentAnalysisEnd == null ) {
            __independentAnalysisEnd = new DateTime(__tsIndependent.getDate2());
        }
        else {
            __independentAnalysisEnd = new DateTime(independentAnalysisEnd);
        }
    }
    // Minimum sample size
    if ( minimumSampleSize == null ) {
        // Needed minimum of 2 to avoid division by zero
        minimumSampleSize = 2;
    }
    __minimumSampleSize = minimumSampleSize;
    // Minimum R
    __minimumR = minimumR;
    // Confidence interval
    __confidenceIntervalPercent = confidenceInterval;
    // Fill period...
    if ( fillStart == null ) {
        __fillStart = new DateTime(tsToFill.getDate1());
    }
    else {
        __fillStart = new DateTime(fillStart);
    }
    if ( fillEnd == null ) {
        __fillEnd = new DateTime(tsToFill.getDate2());
    }
    else {
        __fillEnd = new DateTime(fillEnd);
    }
    __fillFlag = fillFlag;
    __fillFlagDesc = fillFlagDesc;
    __doFill = doFill;
    __descriptionString = descriptionString;
}

/**
Fill the dependent time series using the relationship(s) that have been computed.
*/
private void fillDependentTS ()
{
    String routine = getClass().getName() + "TSUtil.fillDependentTS";
    int dl = 50; // Debug level

    List<String> problems = getProblems();
    RegressionType analysisMethod = getAnalysisMethod();
    NumberOfEquationsType numberOfEquations = getNumberOfEquations();
    int [] analysisMonths = getAnalysisMonths();
    DataTransformationType transformation = getTransformation();
    TS tsToFill = getTSToFill();
    TS tsIndependent = getIndependentTS();
    String fillFlag = getFillFlag();
    TSRegressionAnalysis analysis = getTSRegressionAnalysis();
    TSRegressionResults analysisResults = null;
    if ( transformation == DataTransformationType.NONE ) {
        analysisResults = analysis.getTSRegressionResults();
    }
    else {
        analysisResults = analysis.getTSRegressionResultsTransformed();
    }
    boolean [] regressionChecksMask = null;
    RegressionChecks regressionChecks = null;
    RegressionData regressionData = null;
    RegressionEstimateErrors regressionErrors = null;
    RegressionFilledValues singleregressionFilledValues = null;
    if ( numberOfEquations == NumberOfEquationsType.ONE_EQUATION ) {
        regressionChecksMask = analysis.getTSRegressionChecksMaskSingle();
    }
    else if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
        regressionChecksMask = analysis.getTSRegressionChecksMaskMonthly();
    }
    Double leZeroLogValue = getLEZeroLogValue();
    double leZeroLogValue2 = Math.log10(leZeroLogValue);
    
    int intervalBase = tsToFill.getDataIntervalBase();
    int intervalMult = tsToFill.getDataIntervalMult();

    boolean fillFlag_boolean = false; // Indicate whether to use flag
    if ( (fillFlag != null) && (fillFlag.length() > 0) ) {
        fillFlag_boolean = true;
    }

    DateTime fillStart = getFillStart();
    DateTime fillEnd = getFillEnd();

    int errorCount = 0; // Count of errors filling (limited to 100 because most likely a logic issue)
    double newval = 0.0, x = 0.0;
    double a, b; // Coefficients for regression relationship
    int fillCountSingle = 0; // To know whether to add to genesis
    int [] fillCountMonthly = new int[12];
    int month = 0; // Used for analysisMonths check
    boolean [] analysisMonthsMask = analysis.getAnalysisMonthsMask();
    // Arrays for filled values, used to compute post-filling statistics
    int fullDataCount = TSUtil.calculateDataSize(tsToFill, fillStart, fillEnd);
    double [] singleEquationFilledValues = new double[fullDataCount];
    double [][] monthlyEquationFilledValues = new double[12][fullDataCount];
    Message.printStatus ( 2, routine, "Filling dependent time series \"" +
        tsToFill.getIdentifier().toStringAliasAndTSID() + "\" from " + fillStart + " to " + fillEnd );
    for ( DateTime date = new DateTime ( fillStart ); date.lessThanOrEqualTo( fillEnd );
        date.addInterval(intervalBase, intervalMult) ) {
        month = date.getMonth();
        try {
            // TODO SAM - need to evaluate this - use isAnalyzed() to improve performance
            if ( tsToFill.isDataMissing(tsToFill.getDataValue(date)) ) {
                // Try to fill the value...
                x = tsIndependent.getDataValue ( date );
                if ( tsIndependent.isDataMissing(x) ) {
                    // No independent value so can't fill
                    Message.printStatus ( 2, routine,
                        "Missing at " + date + " - can't fill because indep is missing.");
                    continue;
                }
                if ( !regressionChecksMask[month - 1] ) {
                    // Don't have a valid relationship to do filling for month so skip value
                    if ( numberOfEquations == NumberOfEquationsType.ONE_EQUATION ) {
                        regressionChecks = analysis.getTSRegressionChecksTransformed().getSingleEquationRegressionChecks();
                        regressionData = analysis.getTSRegressionDataTransformed().getSingleEquationRegressionData();
                        regressionErrors = analysis.getTSRegressionErrorsTransformed().getSingleEquationRegressionErrors();
                        //regressionFilledValues = getTSRegressionFilledValues().getSingleEquationRegressionFilledValues();
                    }
                    else if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
                        regressionChecks = analysis.getTSRegressionChecksTransformed().getMonthlyEquationRegressionChecks(month);
                        regressionData = analysis.getTSRegressionDataTransformed().getMonthlyEquationRegressionData(month);
                        regressionErrors = analysis.getTSRegressionErrorsTransformed().getMonthlyEquationRegressionErrors(month);
                        //regressionFilledValues = getTSRegressionFilledValues().getMonthlyEquationRegressionFilledValues(month);
                    }
                    Message.printStatus ( 2, routine,
                        "Missing at " + date + " - can't fill because relationship is invalid (" +
                        regressionChecks.formatInvalidRelationshipReason() + ").");
                    continue;
                }
                // TODO SAM 2012-01-16 The following is probably redundant given the above check
                // Skip the month if not requested
                if ( !analysisMonthsMask[month - 1] ) {
                    continue;
                }
                if ( Message.isDebugOn ) {
                    Message.printDebug ( dl, routine, "Found nonmissing independant data at " + date + " - value: " + x  );
                }
                if ( transformation == DataTransformationType.LOG ) {
                    // Need to work on the log of the X value...
                    if ( x <= 0.0 ) {
                        x = leZeroLogValue2;
                    }
                    else {
                        x = Math.log10(x);
                    }
                    if ( Message.isDebugOn ) {
                        Message.printDebug ( dl, routine, "Using log value: " + x);
                    }
                }

                if ( numberOfEquations == NumberOfEquationsType.ONE_EQUATION ) {
                    a = analysisResults.getSingleEquationRegressionResults().getA();
                    b = analysisResults.getSingleEquationRegressionResults().getB();
                }
                else {
                    a = analysisResults.getMonthlyEquationRegressionResults(month).getA();
                    b = analysisResults.getMonthlyEquationRegressionResults(month).getB();
                }
                newval = a + b*x;

                if ( Message.isDebugOn ) {
                    Message.printDebug ( dl, routine, "Calculated dependent value: " + newval );
                }

                if ( transformation == DataTransformationType.LOG ) {
                    // Now convert Y back from log10 space...
                    if ( Message.isDebugOn ) {
                        Message.printDebug ( dl, routine, "Must use inverse log for " + newval );
                    }
                    if ( fillFlag_boolean ) {
                        // Set the flag...
                        tsToFill.setDataValue ( date, Math.pow ( 10, newval ), fillFlag, 1 );
                    }
                    else {
                        // No flag...
                        tsToFill.setDataValue ( date, Math.pow ( 10, newval ));
                    }
                }
                else {
                    if ( fillFlag_boolean ) {
                        // Set the flag...
                        tsToFill.setDataValue(date, newval, fillFlag, 1 );
                    }
                    else {
                        // No flag...
                        tsToFill.setDataValue(date, newval );
                    }
                }
                // Increment the counter on the number of values filled
                if ( numberOfEquations == NumberOfEquationsType.ONE_EQUATION ) {
                    singleEquationFilledValues[fillCountSingle] = newval;
                    ++fillCountSingle;
                }
                else if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
                    monthlyEquationFilledValues[month - 1][fillCountMonthly[month - 1]] = newval;
                    ++fillCountMonthly[month - 1];
                }
            }
            // TODO SAM 2012-05-21 Figure out what to do with transformed values
            // Set the filled values arrays.  Resize based on the actual number of filled values.
            double [] singleEquationFilledValues2 = new double[0];
            double [][] monthlyEquationFilledValues2 = new double[12][0];
            RegressionFilledValues [] monthlyRegressionFilledValues = new RegressionFilledValues[12];
            if ( numberOfEquations == NumberOfEquationsType.ONE_EQUATION ) {
                singleEquationFilledValues2 = new double[fillCountSingle];
                System.arraycopy(singleEquationFilledValues, 0, singleEquationFilledValues2, 0, fillCountSingle);
            }
            else if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
                for ( int i = 0; i < 12; i++ ) {
                    monthlyEquationFilledValues2[i] = new double[fillCountMonthly[i]];
                    System.arraycopy(monthlyEquationFilledValues[i], 0, monthlyEquationFilledValues2[i], 0, fillCountMonthly[i]);
                }
            }
            setTSRegressionFilledValues( new TSRegressionFilledValues(tsToFill,
                new RegressionFilledValues(singleEquationFilledValues2),
                monthlyRegressionFilledValues));
        }
        catch ( Exception e ) {
            // Error filling interval - this likely is a logic or error-handling issue and needs
            // to be resolved
            problems.add ( "Error filling value at " + date + " (" + e + ")." );
            if ( errorCount++ < 100 ) {
                Message.printWarning ( 3, routine, e );
            }
        }
    }

    // Fill in the genesis information...

    if ( fillCountSingle > 0 ) {
        tsToFill.addToGenesis ( "Filled " + fillCountSingle + " missing values " + fillStart + " to " + fillEnd + " using analysis results:" );
    
        // The following comes back as multiple strings but to handle genesis
        // information nicely, break into separate strings...
    
        List<String> strings = StringUtil.breakStringList ( analysis.toString(),
            System.getProperty("line.separator"), StringUtil.DELIM_SKIP_BLANKS );
        for ( String string : strings ) {
            tsToFill.addToGenesis( string );
        }

        String descriptionString = getDescriptionString();
        if ( descriptionString != null ) {
            // Description has been specified...
            tsToFill.setDescription ( tsToFill.getDescription() + descriptionString );
        }
        else {
            // Automatically add to the description...
            String monthString = "monthly";
            if ( (analysisMonths != null) && (analysisMonths.length == 1) ) {
                // Filling one month so be specific in the description
                monthString = TimeUtil.monthAbbreviation(analysisMonths[0]);
            }
            if ( transformation == DataTransformationType.LOG ) {
                tsToFill.setDescription ( tsToFill.getDescription()+
                ", fill log " + analysisMethod + " " + monthString + " using " + tsIndependent.getIdentifierString() );
            }
            else {
                tsToFill.setDescription ( tsToFill.getDescription() +
                ", fill " + analysisMethod + " " + monthString + " using " + tsIndependent.getIdentifierString() );
            }
        }
    }
}

/**
Perform the analysis and fill the time series.
*/
public void fillRegression ()
{   String routine = getClass().getName() + ".fillRegression";
    // Construct the analysis object
    boolean analyzeSingleEquation = false;
    boolean analyzeMonthlyEquations = false;
    // TODO SAM 2012-01-16 Currently the following does nothing (useful for Mixed Station Analysis that needs
    // both single and monthly relationships), resulting in a performance hit
    if ( getNumberOfEquations() == NumberOfEquationsType.ONE_EQUATION ) {
        analyzeSingleEquation = true;
        analyzeMonthlyEquations = false;
    }
    else if ( getNumberOfEquations() == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
        analyzeSingleEquation = false;
        analyzeMonthlyEquations = true;
    }
    // Initialize...
    TSRegressionAnalysis ra = new TSRegressionAnalysis ( getIndependentTS(), getTSToFill(),
        getAnalysisMethod(),
        analyzeSingleEquation,
        analyzeMonthlyEquations,
        getAnalysisMonths(),
        getTransformation(), getLEZeroLogValue(), getForcedIntercept(),
        getDependentAnalysisStart(), getDependentAnalysisEnd(),
        getIndependentAnalysisStart(), getIndependentAnalysisEnd(), getConfidenceIntervalPercent() );
    setTSRegressionAnalysis ( ra );
    // Analyze for filling
    ra.analyzeForFilling(getMinimumSampleSize(), getMinimumR(), getConfidenceIntervalPercent() );
    // Do the filling...
    if ( getDoFill() ) {
        fillDependentTS ();
    }
    else {
        Message.printStatus ( 2, routine, "Fill=False ... dependent time series will NOT be filled!" );
    }
}

/**
Return the analysis method.
@return the analysis method.
*/
private RegressionType getAnalysisMethod ()
{
    return __analysisMethod;
}

/**
Return an array indicating the months to be analyzed, each value 1-12.  This information
corresponds to the AnalysisMonth property that is passed in at construction.
@return the array containing the months (1-12) to be analyzed, or null if all months will be analyzed.
*/
public int [] getAnalysisMonths ()
{   return __analysisMonths;
}

/**
Return the dependent time series analysis end.
@return the dependent time series analysis end.
*/
public DateTime getDependentAnalysisEnd()
{   return __dependentAnalysisEnd;
}

/**
Return the dependent time series analysis start.
@return the dependent time series analysis start.
*/
public DateTime getDependentAnalysisStart()
{   return __dependentAnalysisStart;
}

/**
Return the description string.
*/
public String getDescriptionString ()
{
    return __descriptionString;
}

/**
Return whether to fill.
@return whether to fill.
*/
public boolean getDoFill()
{   return __doFill;
}

/**
Return the fill end.
@return the fill end.
*/
public DateTime getFillEnd()
{   return __fillEnd;
}

/**
Return the fill flag.
*/
public String getFillFlag ()
{
    return __fillFlag;
}

/**
Return the fill flag description.
*/
public String getFillFlagDesc ()
{
    return __fillFlagDesc;
}

/**
Return the independent time series analysis start.
@return the independent time series analysis start.
*/
public DateTime getFillStart()
{   return __fillStart;
}

/**
Return the forced intercept.
@return the forced intercept.
*/
public Double getForcedIntercept ()
{   return __forcedIntercept;
}

/**
Return the independent time series analysis end.
@return the independent time series analysis end.
*/
public DateTime getIndependentAnalysisEnd()
{   return __independentAnalysisEnd;
}

/**
Return the independent time series analysis start.
@return the independent time series analysis start.
*/
public DateTime getIndependentAnalysisStart()
{   return __independentAnalysisStart;
}

/**
Return the independent (X) time series.
@return the independent (X) time series.
*/
private TS getIndependentTS()
{   return __tsIndependent;
}

/**
Return the value that will be used for the log transform if the original is <= 0.
@return the value that will be used for the log transform if the original is <= 0.
*/
private double getLEZeroLogValue ()
{   return __leZeroLogValue;
}

/**
Return the minimum acceptable R - if null then R is not checked.
@return the minimum acceptable R.
*/
public Double getMinimumR ()
{   return __minimumR;
}

/**
Return the minimum acceptable sample size - if null then sample size is not checked.
@return the minimum acceptable sample size.
*/
public Integer getMinimumSampleSize ()
{   return __minimumSampleSize;
}

/**
Return the confidence interval that must be met - if null then confidence interval is not checked.
@return the confidence interval that must be met.
*/
public Double getConfidenceIntervalPercent ()
{   return __confidenceIntervalPercent;
}

/**
Indicate whether the analysis is performed using one equation or monthly equations.
@return the number of equations used for the analysis.
*/
private NumberOfEquationsType getNumberOfEquations( )
{   return __numberOfEquations;
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems ()
{
    return __problems;
}

/**
Get the transformation that is being applied to the data prior to the analysis.
@return the transformation that is being applied to the data prior to the analysis.
*/
public DataTransformationType getTransformation ( )
{   return __transformation;
}

/**
Return the TSRegressionAnalysis object.
@return the TSRegressionAnalysis object.
*/
public TSRegressionAnalysis getTSRegressionAnalysis ()
{
    return __tsRegressionAnalysis;
}

/**
Return the TSRegressionFilledValues object.
@return the TSRegressionFilledValues object.
*/
public TSRegressionFilledValues getTSRegressionFilledValues ()
{
    return __tsRegressionFilledValues;
}

/**
Return the time series to fill (Y).
@return the time series to fill (Y).
*/
private TS getTSToFill()
{   return __tsToFill;
}

/**
Save the statistics from the regression analysis to a table object.
@param ts dependent time series
@param table the table to save the results
@param tableTSIDColumnName the name of the table column containing the TSID/alias to match
@param tableTSIDFormat the format string for the time series - to allow matching the contents of the
tableTSIDColumnName
@param regressionType the regression type, which will impact formatting of results (independent analysis period
is specific to MOVE2)
@param numberOfEquations the number of equations in the analysis, which will impact the number of columns
in the output (whether or not monthly statistics are shown)
@param transformat the data transformation, which will impact the number of columns (whether or not transformed
data are shown)
*/
public void saveStatisticsToTable ( TS ts, DataTable table,
    String tableTSIDColumnName, String tableTSIDFormat, RegressionType regressionType,
    NumberOfEquationsType numberOfEquations,
    DataTransformationType transformation
    //,boolean includeRaw, boolean includeTransformed
    )
throws Exception
{   String routine = getClass().getName() + ".saveStatisticsToTable";
    // Verify that the TSID table columns are available for dependent and independent time series
    String tableTSIDColumnNameIndependent = tableTSIDColumnName + "_Independent";
    int tableTSIDColumnNumber = -1;
    int tableTSIDColumnNumberIndependent = -1;
    // If the TSID column name does not exist, add it to the table
    try {
        tableTSIDColumnNumber = table.getFieldIndex(tableTSIDColumnName);
    }
    catch ( Exception e2 ) {
        // Automatically add to the table, initialize with null (not nonValue)
        table.addField(new TableField(TableField.DATA_TYPE_STRING,tableTSIDColumnName,-1,-1), null );
        // Get the corresponding column number for row-edits below
        tableTSIDColumnNumber = table.getFieldIndex(tableTSIDColumnName);
        // Set the description, which is used as the tool tip in the UI
        table.getTableField(tableTSIDColumnNumber).setDescription("Dependent time series identifier");
    }
    // If the TSID_Independent column does not exist, add it to the table
    try {
        tableTSIDColumnNumberIndependent = table.getFieldIndex(tableTSIDColumnNameIndependent);
    }
    catch ( Exception e2 ) {
        // Automatically add to the table, initialize with null (not nonValue)
        table.addField(new TableField(TableField.DATA_TYPE_STRING,tableTSIDColumnNameIndependent,-1,-1), null );
        // Get the corresponding column number for row-edits below
        tableTSIDColumnNumberIndependent = table.getFieldIndex(tableTSIDColumnNameIndependent);
        // Set the description, which is used as the tool tip in the UI
        table.getTableField(tableTSIDColumnNumberIndependent).setDescription("Independent time series identifier");
    }
    // Add additional generic columns, for informational purposes - put these here to avoid
    // duplication for each month if monthly analysis
    List<String> columnsToAdd = new Vector();
    columnsToAdd.add ( "AnalysisMethod" );
    columnsToAdd.add ( "DependentAnalysisStart" );
    columnsToAdd.add ( "DependentAnalysisEnd" );
    // TODO SAM 2012-05-24 Evaluate whether the following 2 are confusing for normal OLS regression
    columnsToAdd.add ( "IndependentAnalysisStart" );
    columnsToAdd.add ( "IndependentAnalysisEnd" );
    columnsToAdd.add ( "FillStart" );
    columnsToAdd.add ( "FillEnd" );
    columnsToAdd.add ( "Transformation" );
    columnsToAdd.add ( "MinimumSampleSize" );
    columnsToAdd.add ( "MinimumR" );
    columnsToAdd.add ( "ConfidenceInterval" );
    List<String> descriptionsToAdd = new Vector();
    descriptionsToAdd.add ( "Regression analysis method (Ordinary Least Squares or Maintenance of Variation 2)" );
    descriptionsToAdd.add ( "Dependent time series analysis period start, used to determine relationships" );
    descriptionsToAdd.add ( "Dependent time series analysis period end, used to determine relationships" );
    if ( regressionType == RegressionType.OLS_REGRESSION ) {
        descriptionsToAdd.add ( "Independent time series analysis period start (same as DependentAnalysisStart for OLS regression), used to determine relationships" );
        descriptionsToAdd.add ( "Independent time series analysis period end (same as DependentAnalysisStart for OLS regression), used to determine relationships" );
    }
    else if ( regressionType == RegressionType.MOVE2 ) {
        descriptionsToAdd.add ( "Independent time series analysis period start, used to determine relationships" );
        descriptionsToAdd.add ( "Independent time series analysis period end, used to determine relationships" );
    }
    else {
        descriptionsToAdd.add ( "" );
        descriptionsToAdd.add ( "" );
    }
    descriptionsToAdd.add ( "Fill period start" );
    descriptionsToAdd.add ( "Fill period end" );
    descriptionsToAdd.add ( "Transformation performed on data prior to determining relationship" );
    descriptionsToAdd.add ( "Minimum sample size (N1) to consider the relationship valid" );
    descriptionsToAdd.add ( "Minimum R to consider the relationship valid" );
    descriptionsToAdd.add ( "Confidence interval (%) required for relationship line slope" );
    for ( int i = 0; i < columnsToAdd.size(); i++ ) {
        try {
            table.getFieldIndex(columnsToAdd.get(i));
        }
        catch ( Exception e2 ) {
            // Automatically add to the table, initialize with null (not nonValue)
            if ( columnsToAdd.get(i).equalsIgnoreCase("ConfidenceInterval") ||
                columnsToAdd.get(i).equalsIgnoreCase("MinimumR")) {
                // Floating point
                table.addField(new TableField(
                    TableField.DATA_TYPE_DOUBLE,columnsToAdd.get(i),-1,8), null );
            }
            else if ( columnsToAdd.get(i).equalsIgnoreCase("MinimumSampleSize") ) {
                // Integer
                table.addField(new TableField(
                    TableField.DATA_TYPE_INT,columnsToAdd.get(i),-1,-1), null );
            }
            else {
                // Rest are strings
                table.addField(new TableField(TableField.DATA_TYPE_STRING,columnsToAdd.get(i),-1,-1), null );
                // Set the description, which is used as the tool tip in the UI
                table.getTableField(table.getFieldIndex(columnsToAdd.get(i))).setDescription(descriptionsToAdd.get(i));
            }
        }
    }
    // Loop through the statistics, creating table column names if necessary
    // Do this first so that all columns are fully defined.  Then process the row values below.
    int numEquations = 1;
    if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
        numEquations = 12;
    }
    // List in a reasonable order - see the command documentation for more
    // X=independent
    // Y=dependent
    List<String> statsToOutput = new Vector();
    // Statistics that have _trans are for transformed data and will only be output if a transformation
    // has been specified
    // Statistics from the input data...
    statsToOutput.add ( "N1" ); // Same for raw and transformed
    statsToOutput.add ( "MeanX1" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "MeanX1_tran" );
    }
    statsToOutput.add ( "SX1" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "SX1_tran" );
    }
    statsToOutput.add ( "N2" );
    statsToOutput.add ( "MeanX2" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "MeanX2_tran" );
    }
    statsToOutput.add ( "SX2" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "SX2_tran" );
    }
    statsToOutput.add ( "MeanY1" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "MeanY1_tran" );
    }
    statsToOutput.add ( "SY1" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "SY1_tran" );
    }
    statsToOutput.add ( "NY" );
    statsToOutput.add ( "MeanY" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "MeanY_tran" );
    }
    statsToOutput.add ( "SY" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "SY_tran" );
    };
    statsToOutput.add ( "SkewY" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "SkewY_tran" );
    };
    // Statistics from the analysis results...
    if ( transformation == DataTransformationType.NONE ) {
        statsToOutput.add ( "a" );
        statsToOutput.add ( "b" );
        statsToOutput.add ( "R" );
        statsToOutput.add ( "R2" );
    }
    else {
        statsToOutput.add ( "a_tran" );
        statsToOutput.add ( "b_tran" );
        statsToOutput.add ( "R_tran" );
        statsToOutput.add ( "R2_tran" );
    }
    // Statistics from the error estimates...
    statsToOutput.add ( "MeanY1est" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "MeanY1est_trans" );
    }
    statsToOutput.add ( "SY1est" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "SY1est_trans" );
    }
    statsToOutput.add ( "RMSE" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "RMSE_trans" );
    }
    statsToOutput.add ( "SEE" );
    if ( transformation != DataTransformationType.NONE ) {
        statsToOutput.add ( "SEE_trans" );
    }
    if ( transformation == DataTransformationType.NONE ) {
        statsToOutput.add ( "SESlope" );
        statsToOutput.add ( "TestScore" );
        statsToOutput.add ( "TestQuantile" );
        statsToOutput.add ( "TestOK" );
        statsToOutput.add ( "SampleSizeOK" );
        statsToOutput.add ( "ROK" );
    }
    else {
        statsToOutput.add ( "SESlope_trans" );
        statsToOutput.add ( "TestScore_trans" );
        statsToOutput.add ( "TestQuantile_trans" );
        statsToOutput.add ( "TestOK_trans" );
        statsToOutput.add ( "SampleSizeOK_trans" );
        statsToOutput.add ( "ROK_trans" );
    }
    // Statistics from the filled data, always in data space
    // (include for comparison with mixed station analysis)...
    statsToOutput.add ( "NYfilled" );
    statsToOutput.add ( "MeanYfilled" );
    statsToOutput.add ( "SYfilled" );
    statsToOutput.add ( "SkewYfilled" );
    // The following comments parallel the statistics names are used to create comments in the table header
    String [] mainComments = {
        "",
        "The following statistics are computed to determine and evaluate the the regression relationships.",
        "The regression type performed was:  " + getAnalysisMethod(),
        "X indicates the independent time series and Y indicates the dependent time series.",
        "Some statistics are ignored for some regression approaches, but are provided for comparison.",
        ""
    };
    String [] mainCommentsMonthly = {
        "",
        "Monthly statistics (for case where NumberOfEquations=MonthlyEquatations) will have a _M subscript, " +
        "where M is the month (1=January, 12=December).",
        ""
        };
    HashMap<String,String> statisticComments = new HashMap();
    statisticComments.put("N1","Count of non-missing data points overlapping in the dependent and independent time series in the analysis period");
    statisticComments.put("MeanX1","Mean of the independent N1 values");
    statisticComments.put("SX1","Standard deviation of the independent N1 values");
    statisticComments.put("N2","Count of the non-missing data points in the independent time series outside of N1 in the analysis period");
    statisticComments.put("MeanX2","Mean of the independent N2 values");
    statisticComments.put("SX2","Standard deviation of the independent N2 values");
    statisticComments.put("MeanY1","Mean of the dependent N1 values");
    statisticComments.put("SY1","Standard deviation of the dependent N1 values");
    statisticComments.put("NY","Count of the non-missing dependent values in the analysis period");
    statisticComments.put("MeanY","Mean of the NY dependent values in the analysis period");
    statisticComments.put("SY","Standard deviation of the NY dependent values in the analysis period");
    statisticComments.put("a","The intercept for the relationship equation");
    statisticComments.put("b","The slope of the relationship equation");
    statisticComments.put("R","The correlation coefficient for N1 values");
    statisticComments.put("R2","R-squared, coefficient of determination for N1 values");
    statisticComments.put("MeanY1est",
        "Mean of N1 values computed from the relationship (estimate dependent N1 values where previously known)");
    statisticComments.put("SY1est",
        "Standard deviation of N1 values computed from the relationship (estimate dependent N1 values where previously known");
    statisticComments.put("RMSE","Root mean squared error for N1 values, computed from regression relationship estimated values");
    statisticComments.put("SEE","Standard error of estimate for N1 values, computed from regression relationship estimated values");
    statisticComments.put("SEP","Standard error of prediction for N1 values, computed from regression relationship estimated values");
    statisticComments.put("SEslope","Standard error (SE) of the slope (b) for N1 values, computed from regression relationship estimated values");
    statisticComments.put("TestScore","b/SE");
    statisticComments.put("TestQuantile","From the Student's T-test, function of confidence interval and degrees of freedom, DF (N1 - 2)");
    statisticComments.put("TestOK","Yes if TestScore >= TestQuantile, No if otherwise");
    statisticComments.put("SampleSizeOK","Yes if sample size >= minimum sample size, No if otherwise");
    statisticComments.put("ROK","Yes if R >= minimum R, No if otherwise");
    // Put these in for comparison with mixed station analysis
    statisticComments.put("NYfilled","Number of dependent values filled in the fill period");
    statisticComments.put("MeanYfilled","Mean of the filled values");
    statisticComments.put("SYfilled","Standard deviation of the filled values");
    statisticComments.put("SkewYfilled","Skew of the filled values");
    // Add comments to the table header
    table.addToComments(Arrays.asList(mainComments));
    if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
        table.addToComments(Arrays.asList(mainCommentsMonthly));
    }
    int i = 0;
    // FIXME SAM 2012-01-16 Need to add statistics comments
    //for ( String comment: statisticComments ) {
    //    table.addToComments(statistics[i++] + " - " + comment);
    //}
    table.addToComments ( "" );
    int countStatisticTotal = statsToOutput.size()*numEquations; // The total number of statistics columns to add
    String [] statisticColumnNames = new String[countStatisticTotal]; // names in table
    int [] statisticFieldType = new int[countStatisticTotal]; // value types
    // Arrays for the statistics.  Using multiple arrays will result in some statistic
    // values being null; however this is easier than dealing with casts later in the code
    Double [] statisticValueDouble = new Double[countStatisticTotal];
    Integer [] statisticValueInteger = new Integer[countStatisticTotal];
    String [] statisticValueString = new String[countStatisticTotal];
    //String [] statisticValueString = new String[countStatisticTotal];
    // The count of statistics added (0-index), necessary because when dealing with monthly statistics
    // the 12 months are flattened into a linear array matching column headings
    int countStatistic = -1;
    // Get the main sub-objects associated with the analysis
    TSRegressionAnalysis analysis = getTSRegressionAnalysis();
    TSRegressionData tsRegressionData = analysis.getTSRegressionData();
    TSRegressionData tsRegressionDataTransformed = analysis.getTSRegressionDataTransformed();
    TSRegressionResults tsRegressionResults = analysis.getTSRegressionResults();
    TSRegressionResults tsRegressionResultsTransformed = analysis.getTSRegressionResultsTransformed();
    TSRegressionEstimateErrors tsRegressionEstimateErrors = analysis.getTSRegressionEstimateErrors();
    TSRegressionChecks tsRegressionChecks = analysis.getTSRegressionChecksTransformed();
    TSRegressionFilledValues tsRegressionFilledValues = getTSRegressionFilledValues();
    String statisticName; // Statistic to output
    String statisticColumnName; // Name of the column for the statistic being processed
    for ( int iEquation = 1; iEquation <= numEquations; iEquation++ ) {
        for ( int iStatistic = 0; iStatistic < statsToOutput.size(); iStatistic++ ) {
            statisticName = statsToOutput.get(iStatistic);
            // Set statistics to null (one will be set below).
            ++countStatistic;
            statisticValueDouble[countStatistic] = null;
            statisticValueInteger[countStatistic] = null;
            // Column name for the statistic (list alphabetically)...
            if ( numEquations == 1 ) {
                statisticColumnNames[countStatistic] = statisticName;
            }
            else {
                statisticColumnNames[countStatistic] = statisticName + "_" + iEquation;
            }
            if ( statisticName.equals("a") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getSingleEquationRegressionResults().getA();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getA();
                }
            }
            else if ( statisticName.equals("AnalysisStart") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getSingleEquationRegressionResults().getA();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getA();
                }
            }
            else if ( statisticName.equals("a_trans") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResultsTransformed.getSingleEquationRegressionResults().getA();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResultsTransformed.getMonthlyEquationRegressionResults(iEquation).getA();
                }
            }
            else if ( statisticName.equals("b") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getSingleEquationRegressionResults().getB();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getB();
                }
            }
            else if ( statisticName.equals("b_trans") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResultsTransformed.getSingleEquationRegressionResults().getB();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResultsTransformed.getMonthlyEquationRegressionResults(iEquation).getB();
                }
            }
            else if ( statisticName.equals("MeanX") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getMeanX();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanX();
                }
            }
            else if ( statisticName.equals("MeanX1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getMeanX1();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanX1();
                }
            }
            else if ( statisticName.equals("MeanX2") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getMeanX2();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanX2();
                }
            }
            else if ( statisticName.equals("MeanY") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getMeanY();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanY();
                }
            }
            else if ( statisticName.equals("MeanYfilled") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getMeanYFilled();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getMeanYFilled();
                }
            }
            else if ( statisticName.equals("MeanY1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getMeanY1();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getMeanY1();
                }
            }
            else if ( statisticName.equals("MeanY1est") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getMeanY1est();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getMeanY1est();
                }
            }
            else if ( statisticName.equals("NX") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getN();
                }
                else {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN();
                }
            }
            else if ( statisticName.equals("N1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getN1();
                }
                else {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN1();
                }
            }
            else if ( statisticName.equals("N2") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getN2();
                }
                else {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getN2();
                }
            }
            else if ( statisticName.equals("NY") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getNY();
                }
                else {
                    statisticValueInteger[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getNY();
                }
            }
            else if ( statisticName.equals("NYfilled") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] =
                        tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getNFilled();
                }
                else {
                    statisticValueInteger[countStatistic] =
                        tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getNFilled();
                }
            }
            else if ( statisticName.equals("R") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getSingleEquationRegressionResults().getCorrelationCoefficient();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getCorrelationCoefficient();
                }
            }
            else if ( statisticName.equals("R2") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                Double r = tsRegressionResults.getSingleEquationRegressionResults().getCorrelationCoefficient();
                if ( numEquations == 12 ) {
                    r = tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getCorrelationCoefficient();
                }
                if ( r == null ) {
                    statisticValueDouble[countStatistic] = null;                
                }
                else {
                    Double r2 = new Double(r*r);
                    statisticValueDouble[countStatistic] = r2;
                }
            }
            else if ( statisticName.equals("RMSE") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getRMSE();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getRMSE();
                }
            }
            else if ( statisticName.equals("ROK") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_STRING;
                // Only have a value if the minium R has been specified
                if ( getMinimumR() == null ) {
                    statisticValueString[countStatistic] = "";
                }
                else {
                    boolean rok = tsRegressionChecks.getSingleEquationRegressionChecks().getIsROK();
                    if ( numEquations == 12 ) {
                        rok = tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getIsROK();
                    }
                    if ( rok ) {
                        statisticValueString[countStatistic] = "Yes";
                    }
                    else {
                        statisticValueString[countStatistic] = "No";
                    }
                }
            }
            else if ( statisticName.equals("SampleSizeOK") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_STRING;
                // Minimum sample size will always be specified internally so always show
                boolean ssOk = tsRegressionChecks.getSingleEquationRegressionChecks().getIsSampleSizeOK();
                if ( numEquations == 12 ) {
                    ssOk = tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getIsSampleSizeOK();
                }
                if ( ssOk ) {
                    statisticValueString[countStatistic] = "Yes";
                }
                else {
                    statisticValueString[countStatistic] = "No";
                }
            }
            else if ( statisticName.equals("SEE") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStandardErrorOfEstimate();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStandardErrorOfEstimate();
                }
            }
            else if ( statisticName.equals("SESlope") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStandardErrorOfSlope();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStandardErrorOfSlope();
                }
            }
            /*
            else if ( statisticName.equals("SX") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX());
                }
                else {
                    statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX(iEquation));
                }
            }*/
            else if ( statisticName.equals("SkewY") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getSkewY();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getSkewY();
                }
            }
            else if ( statisticName.equals("SkewYfilled") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getSkewYFilled();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getSkewYFilled();
                }
            }
            else if ( statisticName.equals("SX1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getStandardDeviationX1();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationX1();
                }
            }
            else if ( statisticName.equals("SX2") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getStandardDeviationX2();
                }
                else {
                    statisticValueDouble[countStatistic] = 
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationX2();
                }
            }
            else if ( statisticName.equals("SY") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getStandardDeviationY();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationY();
                }
            }
            else if ( statisticName.equals("SY1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getSingleEquationRegressionData().getStandardDeviationY1();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionData.getMonthlyEquationRegressionData(iEquation).getStandardDeviationY1();
                }
            }
            else if ( statisticName.equals("SY1est") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStandardDeviationY1est();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStandardDeviationY1est();
                }
            }
            else if ( statisticName.equals("SYfilled") ) {
                // Actually filled values
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionFilledValues.getSingleEquationRegressionFilledValues().getStandardDeviationYFilled();
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionFilledValues.getMonthlyEquationRegressionFilledValues(iEquation).getStandardDeviationYFilled();
                }
            }
            else if ( statisticName.equals("TestScore") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getTestScore(
                            tsRegressionResults.getSingleEquationRegressionResults().getB());
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getTestScore(
                             tsRegressionResults.getMonthlyEquationRegressionResults(iEquation).getB() );
                }
            }
            else if ( statisticName.equals("TestQuantile") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                if ( numEquations == 1 ) {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getSingleEquationRegressionErrors().getStudentTTestQuantile(
                            tsRegressionChecks.getSingleEquationRegressionChecks().getConfidenceIntervalPercent());
                }
                else {
                    statisticValueDouble[countStatistic] =
                        tsRegressionEstimateErrors.getMonthlyEquationRegressionErrors(iEquation).getStudentTTestQuantile(
                            tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getConfidenceIntervalPercent() );
                }
            }
            else if ( statisticName.equals("TestOK") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_STRING;
                // Only have a value if the confidence interval has been specified
                if ( getConfidenceIntervalPercent() == null ) {
                    statisticValueString[countStatistic] = "";
                }
                else {
                    Boolean related = tsRegressionChecks.getSingleEquationRegressionChecks().getIsTestOK();
                    if ( numEquations == 12 ) {
                        related = tsRegressionChecks.getMonthlyEquationRegressionChecks(iEquation).getIsTestOK();
                    }
                    if ( related == null ) {
                        statisticValueString[countStatistic] = "";
                    }
                    else if ( related ) {
                        statisticValueString[countStatistic] = "Yes";
                    }
                    else {
                        statisticValueString[countStatistic] = "No";
                    }
                }
            }
            else {
                // Fall through for unrecognized statistics
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                statisticValueDouble[countStatistic] = null;
                Message.printStatus ( 2, routine, "Don't know how to process statistic \"" + statisticName + "\"" );
            }
        }
    }
    // By here the statistics will have been computed and are matched with the column name array
    // Now loop through again and process the row for the dependent and independent time series
    // First format the dependent and independent time series identifiers for to match the table...
    // Dependent time series identifier is configurable from parameter
    String tableTSIDDependent = null;
    if ( (tableTSIDFormat != null) && !tableTSIDFormat.equals("") ) {
        // Format the TSID using the specified format
        tableTSIDDependent = ts.formatLegend ( tableTSIDFormat );
    }
    else {
        // Use the alias if available and then the TSID
        tableTSIDDependent = ts.getAlias();
        if ( (tableTSIDDependent == null) || tableTSIDDependent.equals("") ) {
            tableTSIDDependent = ts.getIdentifierString();
        }
    }
    // Get the independent time series identifier
    String tableTSIDIndependent = null;
    if ( (tableTSIDFormat != null) && !tableTSIDFormat.equals("") ) {
        // Format the TSID using the specified format
        tableTSIDIndependent = getIndependentTS().formatLegend ( tableTSIDFormat );
    }
    else {
        // Use the alias if available and then the TSID
        tableTSIDIndependent = getIndependentTS().getAlias();
        if ( (tableTSIDIndependent == null) || tableTSIDIndependent.equals("") ) {
            tableTSIDIndependent = getIndependentTS().getIdentifierString();
        }
    }
     // Need to make sure that the table has the statistic columns of the correct type,
    // and look up the column numbers from the names in order to do the insert...
    int [] statisticColumnNumbers = new int[countStatisticTotal]; // columns in table
    countStatistic = -1;
    for ( int iEquation = 0; iEquation < numEquations; iEquation++ ) {
        for ( int iStatistic = 0; iStatistic < statsToOutput.size(); iStatistic++ ) {
            ++countStatistic;
            try {
                statisticColumnNumbers[countStatistic] = table.getFieldIndex ( statisticColumnNames[countStatistic] );
            }
            catch ( Exception e ) {
                statisticColumnNumbers[countStatistic] = -1; // Indicates no column name matched in table
            }
            if ( statisticColumnNumbers[countStatistic] < 0 ) {
                // The statistic column does not exist, so add and initialize with null (not nonValue)
                // The value will be set below.
                if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_DOUBLE ) {
                    // Use precision of 8, which should cover most statistics without roundoff
                    // (although this may be too many significant digits for some input).
                    statisticColumnNumbers[countStatistic] =
                        table.addField(new TableField(
                            TableField.DATA_TYPE_DOUBLE,statisticColumnNames[countStatistic],-1,8), null );
                }
                else if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_INT ) {
                    statisticColumnNumbers[countStatistic] =
                        table.addField(new TableField(
                            TableField.DATA_TYPE_INT,statisticColumnNames[countStatistic],-1,-1), null );
                }
                else if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_STRING ) {
                    statisticColumnNumbers[countStatistic] =
                        table.addField(new TableField(
                            TableField.DATA_TYPE_STRING,statisticColumnNames[countStatistic],-1,-1), null );
                }
                Message.printStatus(2,routine,"Added column \"" + statisticColumnNames[countStatistic] +"\" at index "
                     + statisticColumnNumbers[countStatistic] );
            }
            // Set the description for the column so that it can be displayed in table tooltips, etc.
            if ( numEquations == 1 ) {
                table.getTableField(statisticColumnNumbers[countStatistic]).setDescription(
                    statisticComments.get(statisticColumnNames[countStatistic]));
            }
            else {
                table.getTableField(statisticColumnNumbers[countStatistic]).setDescription(
                    statisticComments.get(statisticColumnNames[countStatistic]) +
                    " (Month " + (iEquation + 1) + "=" + TimeUtil.monthAbbreviation(iEquation + 1));
            }
        }
    }
    // Next, find the record that has the dependent and independent identifiers...
    // Find the record that matches the dependent and independent identifiers (should only be one but
    // handle multiple matches)
    List<String> tableColumnNames = new Vector(); // The dependent and independent TSID column names
    tableColumnNames.add ( tableTSIDColumnName );
    tableColumnNames.add ( tableTSIDColumnNameIndependent );
    List<String> tableColumnValues = new Vector(); // The dependent and independent TSID values
    tableColumnValues.add ( tableTSIDDependent );
    tableColumnValues.add ( tableTSIDIndependent );
    List<TableRecord> recList = table.getRecords ( tableColumnNames, tableColumnValues );
    Message.printStatus(2,routine,"Searched for records with columns matching \"" +
        tableTSIDColumnName + "\"=\"" + tableTSIDDependent + "\" " +
        tableTSIDColumnNameIndependent + "\"=\"" + tableTSIDIndependent + "\"... found " + recList.size() );
    if ( recList.size() == 0 ) {
        // No record in the table so add one with TSID column values and blank statistic values...
        TableRecord rec = null;
        table.addRecord(rec=table.emptyRecord());
        rec.setFieldValue(tableTSIDColumnNumber, tableTSIDDependent);
        rec.setFieldValue(tableTSIDColumnNumberIndependent, tableTSIDIndependent);
        recList.add ( rec );
    }
    // Finally loop through the statistics and insert into the rows matched above.  Although multiple
    // records may have been matched, the normal case will be that one record is matched.
    for ( TableRecord rec : recList ) {
        // Set the static column contents
        rec.setFieldValue(table.getFieldIndex("AnalysisMethod"), getAnalysisMethod() );
        rec.setFieldValue(table.getFieldIndex("DependentAnalysisStart"), getDependentAnalysisStart() );
        rec.setFieldValue(table.getFieldIndex("DependentAnalysisEnd"), getDependentAnalysisEnd() );
        rec.setFieldValue(table.getFieldIndex("IndependentAnalysisStart"), getIndependentAnalysisStart() );
        rec.setFieldValue(table.getFieldIndex("IndependentAnalysisEnd"), getIndependentAnalysisEnd() );
        rec.setFieldValue(table.getFieldIndex("FillStart"), getFillStart() );
        rec.setFieldValue(table.getFieldIndex("FillEnd"), getFillEnd() );
        rec.setFieldValue(table.getFieldIndex("MinimumSampleSize"), getMinimumSampleSize() );
        rec.setFieldValue(table.getFieldIndex("MinimumR"), getMinimumR() );
        rec.setFieldValue(table.getFieldIndex("ConfidenceInterval"), getConfidenceIntervalPercent() );
        countStatistic = -1;
        // Set the statistic columns for values that were actually used.
        for ( int iEquation = 0; iEquation < numEquations; iEquation++ ) {
            for ( int iStatistic = 0; iStatistic < statsToOutput.size(); iStatistic++ ) {
                // Set the value based on the object type for the statistic.
                // There can only be one non-null statistic value
                ++countStatistic;
                if ( statisticValueDouble[countStatistic] != null ) {
                    rec.setFieldValue(statisticColumnNumbers[countStatistic],
                        statisticValueDouble[countStatistic]);
                }
                else if ( statisticValueInteger[countStatistic] != null ) {
                    rec.setFieldValue(statisticColumnNumbers[countStatistic],
                        statisticValueInteger[countStatistic]);
                }
                else if ( statisticValueString[countStatistic] != null ) {
                    rec.setFieldValue(statisticColumnNumbers[countStatistic],
                        statisticValueString[countStatistic]);
                }
            }
        }
    }
}

/**
TODO SAM 2012-01-15 This is for the legacy TSRegression object.
Save the statistics from a regression analysis to a table object.
@param ts dependent time series
@param regressionResults results of the regression analysis
@param table the table to save the results
@param tableTSIDColumnName the name of the table column containing the TSID/alias to match
@param tableTSIDFormat the format string for the time series - to allow matching the contents of the
tableTSIDColumnName
@param numberOfEquations the number of equations in the analysis
*/
public void saveStatisticsToTableLegacy ( TS ts, TSRegression regressionResults, DataTable table,
    String tableTSIDColumnName, String tableTSIDFormat, NumberOfEquationsType numberOfEquations )
throws Exception
{   String routine = getClass().getName() + ".saveStatisticsToTable";
    // Verify that the TSID table columns are available for dependent and independent time series
    String tableTSIDColumnNameIndependent = tableTSIDColumnName + "_Independent";
    int tableTSIDColumnNumber = -1;
    int tableTSIDColumnNumberIndependent = -1;
    // If the column name does not exist, add it to the table
    try {
        tableTSIDColumnNumber = table.getFieldIndex(tableTSIDColumnName);
    }
    catch ( Exception e2 ) {
        // Automatically add to the table, initialize with null (not nonValue)
        table.addField(new TableField(TableField.DATA_TYPE_STRING,tableTSIDColumnName,-1,-1), null );
        // Get the corresponding column number for row-edits below
        tableTSIDColumnNumber = table.getFieldIndex(tableTSIDColumnName);
    }
    try {
        tableTSIDColumnNumberIndependent = table.getFieldIndex(tableTSIDColumnNameIndependent);
    }
    catch ( Exception e2 ) {
        // Automatically add to the table, initialize with null (not nonValue)
        table.addField(new TableField(TableField.DATA_TYPE_STRING,tableTSIDColumnNameIndependent,-1,-1), null );
        // Get the corresponding column number for row-edits below
        tableTSIDColumnNumberIndependent = table.getFieldIndex(tableTSIDColumnNameIndependent);
    }
    // Loop through the statistics, creating table column names if necessary
    // Do this first so that all columns are fully defined.  Then process the row values below.
    int numEquations = 1;
    if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
        numEquations = 12;
    }
    // List in a reasonable order - see the command documentation for more
    // X=independent
    // Y=dependent
    //String [] statistics = { };
    String [] statistics = {
        "N1", "MeanX1", "SX1", "N2", "MeanX2", "SX2",
        "MeanY1", "SY1", "NY", "MeanY", "SY", "a", "b", "R", "R2", "MeanY1est", "SY1est",
        "RMSE", "SEE", "SEP", "SESlope", "TestScore", "TestQuantile", "TestRelated",
        // Include for comparison with mixed station analysis
        "NYfilled", "MeanYfilled", "SYfilled", "Skew"
        };
    // The following comments parallel the statistics names are used to create comments in the table header
    String [] mainComments = {
        "",
        "The following statistics are computed to determine and evaluate the the regression relationships.",
        "The regression type performed was:  " + regressionResults.getAnalysisMethod(),
        "X indicates the independent time series and Y indicates the dependent time series.",
        "Some statistics are ignored for some regression approaches, but are provided for comparison.",
        ""
    };
    String [] mainCommentsMonthly = {
            "",
            "Monthly statistics (for case where NumberOfEquations=MonthlyEquatations) will have a _M subscript, " +
            "where M is the month (1=January, 12=December).",
            ""
        };
    String [] statisticComments = {
        "Count of non-missing data points overlapping in the dependent and independent time series", // "N1"
        "Mean of the independent N1 values", // MeanX1
        "Standard deviation of the independent N1 values", // SX1
        "Count of the non-missing data points in the independent time series outside of N1", // N2
        "Mean of the independent N2 values", // MeanX2
        "Standard deviation of the independent N2 values", // SX2
        "Mean of the dependent N1 values", // MeanY1
        "Standard deviation of the dependent N1 values", // SY1
        "Count of the non-missing dependent values", // NY
        "Mean of the NY values", // MeanY
        "Standard deviation of the NY values", // SY
        "The intercept for the relationship equation", // a
        "The slope of the relationship equation", // b
        "The correlation coefficient for N1 values", // R
        "R-squared, coefficient of determination for N1 values", // R2
        "Mean of N1 values computed from the relationship (estimate dependent values where previously known)", // MeanY1est
        "Standard deviation of N1 values computed from the relationship (estimate dependent values where previously known", // SY1est
        "Root mean squared error for N1 values, computed from regression relationship estimated values", // RMSE
        "Standard error of estimate for N1 values, computed from regression relationship estimated values", // SEE
        "Standard error of prediction for N1 values, computed from regression relationship estimated values", // SEP
        "Standard error (SE) of the slope (b) for N1 values, computed from regression relationship estimated values", // SESlope
        "b/SE", // TestScore
        "From the Student's T-test, function of confidence interval and degrees of freedom, DF (N1 - 2)", // TestQuantile
        "Yes if TestScore < TestQuantile, false if otherwise.",
        // Put these in for comparison with mixed station analysis
        "NYfilled",
        "MeanYfilled",
        "SYfilled",
        "Skew"
        };
    // Add comments to the table header
    table.addToComments(Arrays.asList(mainComments));
    if ( numberOfEquations == NumberOfEquationsType.MONTHLY_EQUATIONS ) {
        table.addToComments(Arrays.asList(mainCommentsMonthly));
    }
    int i = 0;
    for ( String comment: statisticComments ) {
        table.addToComments(statistics[i++] + " - " + comment);
    }
    table.addToComments ( "" );
    int countStatisticTotal = statistics.length*numEquations; // The total number of statistics columns to add
    String [] statisticColumnNames = new String[countStatisticTotal]; // names in table
    int [] statisticFieldType = new int[countStatisticTotal]; // value types
    // Arrays for the statistics.  Using multiple arrays will result in some statistic
    // values being null; however this is easier than dealing with casts later in the code
    Double [] statisticValueDouble = new Double[countStatisticTotal];
    Integer [] statisticValueInteger = new Integer[countStatisticTotal];
    //String [] statisticValueString = new String[countStatisticTotal];
    // The count of statistics added (0-index), necessary because when dealing with monthly statistics
    // the 12 months are flattened into a linear array matching column headings
    int countStatistic = -1;
    for ( int iEquation = 1; iEquation <= numEquations; iEquation++ ) {
        for ( int iStatistic = 0; iStatistic < statistics.length; iStatistic++ ) {
            // Set statistics to null (one will be set below).
            ++countStatistic;
            statisticValueDouble[countStatistic] = null;
            statisticValueInteger[countStatistic] = null;
            // Column name for the statistic (list alphabetically)...
            if ( numEquations == 1 ) {
                statisticColumnNames[countStatistic] = statistics[iStatistic];
            }
            else {
                statisticColumnNames[countStatistic] = statistics[iStatistic] + "_" + iEquation;
            }
            if ( statistics[iStatistic].equals("a") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getA());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getA(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("b") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getB());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getB(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("MeanX") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanX());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanX(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("MeanY") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanY());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanY(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("MeanY1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanY1());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanY1(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("MeanY1est") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanY1Estimated());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getMeanY1Estimated(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("NX") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] = new Integer(regressionResults.getN1() +
                        regressionResults.getN2());
                }
                else {
                    statisticValueInteger[countStatistic] = new Integer(regressionResults.getN1(iEquation) +
                        regressionResults.getN2(iEquation));
                }
            }
            else if ( statistics[iStatistic].equals("N1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] = new Integer(regressionResults.getN1());
                }
                else {
                    statisticValueInteger[countStatistic] = new Integer(regressionResults.getN1(iEquation));
                }
            }
            else if ( statistics[iStatistic].equals("N2") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_INT;
                if ( numEquations == 1 ) {
                    statisticValueInteger[countStatistic] = new Integer(regressionResults.getN2());
                }
                else {
                    statisticValueInteger[countStatistic] = new Integer(regressionResults.getN2(iEquation));
                }
            }
            else if ( statistics[iStatistic].equals("R") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] =
                            new Double(regressionResults.getCorrelationCoefficient());
                    }
                    else {
                        statisticValueDouble[countStatistic] =
                            new Double(regressionResults.getCorrelationCoefficient(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("R2") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    double r = regressionResults.getCorrelationCoefficient();
                    if ( numEquations == 12 ) {
                        r = regressionResults.getCorrelationCoefficient(iEquation);
                    }
                    Double r2 = new Double(r*r);
                    statisticValueDouble[countStatistic] = r2;
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("RMSE") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getRMSE());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getRMSE(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("SEE") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardErrorOfEstimate());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardErrorOfEstimate(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            /* FIXME SAM 2011-01-06
            else if ( statistics[iStatistic].equals("SESlope") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardErrorOfSlope());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardErrorOfSlope(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("TestScore") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getTestScore());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getTestScore(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("TestQuantile") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getTestQuantile());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getTestQuantile(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("TestIsRelated") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_STRING;
                try {
                    boolean related = regressionResults.getTestIsRelated();
                    if ( numEquations == 12 ) {
                        related = regressionResults.getTestIsRelated(iEquation);
                    }
                    if ( related ) {
                        statisticValueString[countStatistic] = "Yes";
                    }
                    else {
                        statisticValueString[countStatistic] = "No";
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("SX") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("SX1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX1());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX1(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("SX2") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX2());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationX2(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("SY") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationY());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationY(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("SY1") ) {
                statisticFieldType[countStatistic] = TableField.DATA_TYPE_DOUBLE;
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationY1());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationY1(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            else if ( statistics[iStatistic].equals("SY1est") ) {
                try {
                    if ( numEquations == 1 ) {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationY1Estimated());
                    }
                    else {
                        statisticValueDouble[countStatistic] = new Double(regressionResults.getStandardDeviationY1Estimated(iEquation));
                    }
                }
                catch ( Exception e ) {
                    // No value computed.  Leave as null for output.
                }
            }
            */
        }
    }
    // By here the statistics will have been computed and are matched with the column name array
    // Now loop through again and process the row for the dependent and independent time series
    // First format the dependent and independent time series identifiers for to match the table...
    // Dependent time series identifier is configurable from parameter
    String tableTSIDDependent = null;
    if ( (tableTSIDFormat != null) && !tableTSIDFormat.equals("") ) {
        // Format the TSID using the specified format
        tableTSIDDependent = ts.formatLegend ( tableTSIDFormat );
    }
    else {
        // Use the alias if available and then the TSID
        tableTSIDDependent = ts.getAlias();
        if ( (tableTSIDDependent == null) || tableTSIDDependent.equals("") ) {
            tableTSIDDependent = ts.getIdentifierString();
        }
    }
    // Get the independent time series identifier
    String tableTSIDIndependent = null;
    if ( (tableTSIDFormat != null) && !tableTSIDFormat.equals("") ) {
        // Format the TSID using the specified format
        tableTSIDIndependent = regressionResults.getIndependentTS().formatLegend ( tableTSIDFormat );
    }
    else {
        // Use the alias if available and then the TSID
        tableTSIDIndependent = regressionResults.getIndependentTS().getAlias();
        if ( (tableTSIDIndependent == null) || tableTSIDIndependent.equals("") ) {
            tableTSIDIndependent = regressionResults.getIndependentTS().getIdentifierString();
        }
    }
    // Need to make sure that the table has the statistic columns of the correct type,
    // and look up the column numbers from the names in order to do the insert...
    int [] statisticColumnNumbers = new int[countStatisticTotal]; // columns in table
    countStatistic = -1;
    for ( int iEquation = 0; iEquation < numEquations; iEquation++ ) {
        for ( int iStatistic = 0; iStatistic < statistics.length; iStatistic++ ) {
            ++countStatistic;
            try {
                statisticColumnNumbers[countStatistic] = table.getFieldIndex ( statisticColumnNames[countStatistic] );
            }
            catch ( Exception e ) {
                statisticColumnNumbers[countStatistic] = -1; // Indicates no column name matched in table
            }
            if ( statisticColumnNumbers[countStatistic] < 0 ) {
                // The statistic column does not exist, so add and initialize with null (not nonValue)
                // The value will be set below.
                if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_DOUBLE ) {
                    // Use precision of 8, which should cover most statistics without roundoff
                    // (although this may be too many significant digits for some intput).
                    statisticColumnNumbers[countStatistic] =
                        table.addField(new TableField(
                            TableField.DATA_TYPE_DOUBLE,statisticColumnNames[countStatistic],-1,8), null );
                }
                else if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_INT ) {
                    statisticColumnNumbers[countStatistic] =
                        table.addField(new TableField(
                            TableField.DATA_TYPE_INT,statisticColumnNames[countStatistic],-1,-1), null );
                }
                else if ( statisticFieldType[countStatistic] == TableField.DATA_TYPE_STRING ) {
                    statisticColumnNumbers[countStatistic] =
                        table.addField(new TableField(
                            TableField.DATA_TYPE_STRING,statisticColumnNames[countStatistic],-1,-1), null );
                }
                Message.printStatus(2,routine,"Added column \"" + statisticColumnNames[countStatistic] +"\" at index "
                     + statisticColumnNumbers[countStatistic] );
            }
        }
    }
    // Next, find the record that has the dependent and independent identifiers...
    // Find the record that matches the dependent and independent identifiers (should only be one but
    // handle multiple matches)
    List<String> tableColumnNames = new Vector(); // The dependent and independent TSID column names
    tableColumnNames.add ( tableTSIDColumnName );
    tableColumnNames.add ( tableTSIDColumnNameIndependent );
    List<String> tableColumnValues = new Vector(); // The dependent and independent TSID values
    tableColumnValues.add ( tableTSIDDependent );
    tableColumnValues.add ( tableTSIDIndependent );
    List<TableRecord> recList = table.getRecords ( tableColumnNames, tableColumnValues );
    Message.printStatus(2,routine,"Searched for records with columns matching \"" +
        tableTSIDColumnName + "\"=\"" + tableTSIDDependent + "\" " +
        tableTSIDColumnNameIndependent + "\"=\"" + tableTSIDIndependent + "\"... found " + recList.size() );
    if ( recList.size() == 0 ) {
        // No record in the table so add one with TSID column values and blank statistic values...
        TableRecord rec = null;
        table.addRecord(rec=table.emptyRecord());
        rec.setFieldValue(tableTSIDColumnNumber, tableTSIDDependent);
        rec.setFieldValue(tableTSIDColumnNumberIndependent, tableTSIDIndependent);
        recList.add ( rec );
    }
    // Finally loop through the statistics and insert into the rows matched above.  Although multiple
    // records may have been matched, the normal case will be that one record is matched.  Offset the column
    // number by 2 to account for the dependent and independent time series identifier columns
    for ( TableRecord rec : recList ) {
        countStatistic = -1;
        for ( int iEquation = 0; iEquation < numEquations; iEquation++ ) {
            for ( int iStatistic = 0; iStatistic < statistics.length; iStatistic++ ) {
                // Set the value based on the object type for the statistic...
                ++countStatistic;
                if ( statisticValueDouble[countStatistic] != null ) {
                    rec.setFieldValue(statisticColumnNumbers[countStatistic],
                         statisticValueDouble[countStatistic]);
                }
                if ( statisticValueInteger[countStatistic] != null ) {
                    rec.setFieldValue(statisticColumnNumbers[countStatistic],
                         statisticValueInteger[countStatistic]);
                }
            }
        }
    }
}

/**
Set the TSRegressionAnalysis object.
*/
private void setTSRegressionAnalysis ( TSRegressionAnalysis ra )
{
    __tsRegressionAnalysis = ra;
}

/**
Set the TSRegressionFilledValues object.
*/
private void setTSRegressionFilledValues ( TSRegressionFilledValues fv )
{
    __tsRegressionFilledValues = fv;
}

}