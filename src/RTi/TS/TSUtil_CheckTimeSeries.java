package RTi.TS;

import java.util.List;
import java.util.Vector;

import RTi.Util.Time.DateTime;

/**
Check time series values.
*/
public class TSUtil_CheckTimeSeries
{

/**
Check types that can be performed.
*/
private static String __CHECK_TYPE_ChangeValueInTime = "ChangeValueInTime";
private static String __CHECK_TYPE_ChangePercentInTime = "ChangePercentInTime";
private static String __CHECK_TYPE_InRange = "InRange";
private static String __CHECK_TYPE_OutOfRange = "OutOfRange";
private static String __CHECK_TYPE_Missing = "Missing";
private static String __CHECK_TYPE_Repeat = "Repeat";
private static String __CHECK_TYPE_LessThan = "<";
private static String __CHECK_TYPE_LessThanOrEqualTo = "<=";
private static String __CHECK_TYPE_GreaterThan = ">";
private static String __CHECK_TYPE_GreaterThanOrEqualTo = ">=";
private static String __CHECK_TYPE_EqualTo = "==";

/**
List of problems generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new Vector();

/**
Time series to process.
*/
private TS __ts = null;

/**
Indicator for value to check, either "Raw" or "Statistic".
*/
private String __valueToCheck = null;

/**
Type of check to perform.
*/
private String __checkCriteria = null;

/**
Start of analysis (null to analyze all).
*/
private DateTime __analysisStart = null;

/**
End of analysis (null to analyze all).
*/
private DateTime __analysisEnd = null;

/**
Value as input to analysis, depending on checkType.
*/
private Double __value1 = null;

/**
Start of analysis (null to analyze all).
*/
private Double __value2 = null;

/**
Constructor.
*/
public TSUtil_CheckTimeSeries ( TS ts, String valueToCheck, String checkType,
        DateTime analysisStart, DateTime analysisEnd, Double value1, Double value2, String problemType )
{
	// Save data members.
    __ts = ts;
    __valueToCheck = valueToCheck;
    if ( valueToCheck == null ) {
        __valueToCheck = "Raw";
    }
    __checkCriteria = checkType;
    __analysisStart = analysisStart;
    __analysisEnd = analysisEnd;
    __value1 = value1;
    __value2 = value2;
}

/**
Check the time series.
*/
public void checkTimeSeries ()
throws Exception
{
    // Create a new list of problems
    __problems = new Vector();
    
    // Iterate through the time series
    TS ts = getTimeSeries();
    TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd());
    TSData data = null;
    String valueToCheck = getValueToCheck();
    String checkCriteria = getCheckCriteria();
    double value1 = (getValue1() == null) ? -999.0 : getValue1().doubleValue();
    double value2 = (getValue2() == null) ? -999.0 : getValue2().doubleValue();
    String tsid = ts.getIdentifier().toString();
    if ( (ts.getAlias() != null) && !ts.getAlias().equals("") ) {
        tsid = ts.getAlias();
    }
    double tsvalue; // time series data value
    double tsvaluePrev = 0; // time series data value (previous)
    int tsvalueCount = 0; // Number of values processed
    String message = null;
    DateTime date; // Date corresponding to data value
    while ( (data = tsi.next()) != null ) {
        // Analyze the value - do this brute force with string comparisons and improve performance once logic is in place
        message = null;
        date = tsi.getDate();
        if ( valueToCheck.equals("Raw") ) {
            tsvalue = data.getData();
            if ( checkCriteria.equals(__CHECK_TYPE_ChangePercentInTime) ) {
                if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvalue) && !ts.isDataMissing(tsvalue) &&
                        (Math.abs(((tsvalue - tsvaluePrev)/tsvaluePrev)*100.0) > value1) ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " changed more than " +
                        value1 + " % since previous value " + tsvaluePrev;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_ChangeValueInTime) ) {
                if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvalue) && !ts.isDataMissing(tsvalue) &&
                        (Math.abs(tsvalue - tsvaluePrev) > value1) ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " changed more than " +
                        value1 + " since previous value " + tsvaluePrev;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_EqualTo) ) {
                if ( tsvalue == value1 ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is == test value " + value1;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_GreaterThan) ) {
                if ( tsvalue > value1 ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is > limit " + value1;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_GreaterThanOrEqualTo) ) {
                if ( tsvalue >= value1 ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is >= limit " + value1;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_InRange) ) {
                if ( (tsvalue >= value1) && (tsvalue <= value2) ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is in range " + value1 +
                    " to " + value2;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_LessThan) ) {
                if ( tsvalue < value1 ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is < limit " + value1;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_LessThanOrEqualTo) ) {
                if ( tsvalue <= value1 ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is <= limit " + value1;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_Missing) ) {
                if ( ts.isDataMissing(tsvalue) ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is missing";
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_OutOfRange) ) {
                if ( (tsvalue < value1) || (tsvalue > value2) ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " is out of range " + value1 +
                    " to " + value2;
                }
            }
            else if ( checkCriteria.equals(__CHECK_TYPE_Repeat) ) {
                if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvalue) && !ts.isDataMissing(tsvalue) &&
                        (tsvalue == tsvaluePrev) ) {
                    message = "Time series " + tsid + " value " + tsvalue + " at " + date + " repeated";
                }
            }
            if ( message != null ) {
                // Add to the problems list
                __problems.add ( message );
            }
            // Increment the count and save the previous value
            ++tsvalueCount;
            tsvaluePrev = tsvalue;
        }
        else if ( valueToCheck.equals("Statistic") ) {
            // TODO SAM 2009-04-20 Need to implemented
        }
    }
}

/**
Return the analysis end date/time.
@return the analysis end date/time.
*/
public DateTime getAnalysisEnd ()
{
    return __analysisEnd;
}

/**
Return the analysis start date/time.
@return the analysis start date/time.
*/
public DateTime getAnalysisStart ()
{
    return __analysisStart;
}

/**
Return the check type.
@return the check type.
*/
public String getCheckCriteria ()
{
    return __checkCriteria;
}

/**
Get the list of check types that can be performed.
*/
public static List getCheckCriteriaChoices()
{
    List choices = new Vector();
    choices.add ( __CHECK_TYPE_ChangeValueInTime );
    choices.add ( __CHECK_TYPE_ChangePercentInTime );
    choices.add ( __CHECK_TYPE_InRange );
    choices.add ( __CHECK_TYPE_InRange );
    choices.add ( __CHECK_TYPE_OutOfRange );
    choices.add ( __CHECK_TYPE_Missing );
    choices.add ( __CHECK_TYPE_Repeat );
    choices.add ( __CHECK_TYPE_LessThan );
    choices.add ( __CHECK_TYPE_LessThanOrEqualTo );
    choices.add ( __CHECK_TYPE_GreaterThan );
    choices.add ( __CHECK_TYPE_GreaterThanOrEqualTo );
    choices.add ( __CHECK_TYPE_EqualTo );
    return choices;
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems ()
{
    return __problems;
}

/**
Return the time series being analyzed.
@return the time series being analyzed.
*/
public TS getTimeSeries ()
{
    return __ts;
}

/**
Return Value1 for the check.
@return Value1 for the check.
*/
public Double getValue1 ()
{
    return __value1;
}

/**
Return Value2 for the check.
@return Value2 for the check.
*/
public Double getValue2 ()
{
    return __value2;
}

/**
Return the value to check.
@return the value to check.
*/
public String getValueToCheck ()
{
    return __valueToCheck;
}

}