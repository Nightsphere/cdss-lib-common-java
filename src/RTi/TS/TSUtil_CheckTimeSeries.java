package RTi.TS;

import java.security.InvalidParameterException;
import java.util.List;
import java.util.Vector;

import RTi.Util.Message.Message;
import RTi.Util.String.StringUtil;
import RTi.Util.Time.DateTime;

/**
Check time series values.
*/
public class TSUtil_CheckTimeSeries
{

/**
List of problems generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new Vector();

/**
Time series to process.
*/
private TS __ts = null;

/**
Type of check to perform.
*/
private CheckType __checkCriteria = null;

/**
Start of analysis (null to analyze all).
*/
private DateTime __analysisStart = null;

/**
End of analysis (null to analyze all).
*/
private DateTime __analysisEnd = null;

/**
Value as input to analysis, depending on checkType.
*/
private Double __checkValue1 = null;

/**
Start of analysis (null to analyze all).
*/
private Double __checkValue2 = null;

/**
Flag string for detected values.
*/
private String __flag = null;

/**
Description for __flag.
*/
private String __flagDesc = null;

/**
Action to be performed on detection (either null/blank for no action, "Remove" to remove the data point,
or "SetMissing" to set the data point to missing.  For regular, Remove and SetMissing are equivalent.
*/
private String __action = null;

/**
Constructor.
@param ts time series to check
@param checkType the type of check to perform
@param analysisStart the start of the data period to check
@param analysisEnd the end of the data period to check
@param checkValue1 the first value to check against (depends on check type)
@param checkValue2 the second value to check against (depends on check type)
@param problemType the string problem type to assign when data values match the check criteria
@param flag the data flag to assign to values that match the check criteria
@param flagDesc the description for the data flag (used in summary reports)
@param action the action to be taken for values that match the check criteria (in addition to flagging) - can
be "SetMissing" to set the data value to missing, or "Remove" to remove the point (for irregular time series,
equivalent to "SetMissing" for regular interval data)
*/
public TSUtil_CheckTimeSeries ( TS ts, CheckType checkType,
        DateTime analysisStart, DateTime analysisEnd, Double checkValue1, Double checkValue2, String problemType,
        String flag, String flagDesc, String action )
{   String message;
    String routine = getClass().getName() + ".constructor";
	// Save data members.
    __ts = ts;
    __checkCriteria = checkType;
    __analysisStart = analysisStart;
    __analysisEnd = analysisEnd;
    __checkValue1 = checkValue1;
    __checkValue2 = checkValue2;
    __flag = flag;
    __flagDesc = flagDesc;
    __action = action;
    if ( (__action != null) && __action.equals("") ) {
        // Set to null for internal handling
        __action = null;
    }
    if ( (action != null) && !action.equalsIgnoreCase("Remove") && !action.equalsIgnoreCase("SetMissing")) {
        message = "Action (" + action + ") is invalid.  Must be Remove or SetMissing if specified";
        Message.printWarning(3, routine, message);
        throw new InvalidParameterException ( message );
    }
}

/**
Check the time series.
*/
public void checkTimeSeries ()
throws Exception
{
    // Create a new list of problems
    __problems = new Vector();
    TS ts = getTimeSeries();
    CheckType checkCriteria = getCheckCriteria();
    String tsid = ts.getIdentifier().toString();
    
    // If time series has no data and check is for missing, add a message.
    // Otherwise skip
    if ( !ts.hasData() ) {
        if ( checkCriteria == CheckType.MISSING ) {
            __problems.add ( "Time series " + tsid + " has no data." );
        }
        return;
    }
    
    // Iterate through the time series

    TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd());
    TSData data = null;
    double value1 = (getCheckValue1() == null) ? -999.0 : getCheckValue1().doubleValue();
    double value2 = (getCheckValue2() == null) ? -999.0 : getCheckValue2().doubleValue();
    if ( (ts.getAlias() != null) && !ts.getAlias().equals("") ) {
        tsid = ts.getAlias();
    }
    double tsvalue; // time series data value
    double tsvaluePrev = 0; // time series data value (previous)
    int tsvalueCount = 0; // Number of values processed
    String message = null;
    DateTime date; // Date corresponding to data value
    boolean isMissing;
    boolean matchDetected; // whether a data value matched the check criteria - used to trigger action
    double diff;
    TSData dataPoint = new TSData(); // Used when setting the flag
    // TODO SAM 2010 evaluate whether to check units for precision
    String tsValueFormat = "%.6f"; // Format for values for messages
    while ( (data = tsi.next()) != null ) {
        // Analyze the value - do this brute force with string comparisons and improve performance once logic is in place
        message = null; // A non-null message indicates that the check criteria was met for the value
        date = tsi.getDate();
        matchDetected = false;
        tsvalue = data.getData();
        isMissing = ts.isDataMissing(tsvalue);
        if ( checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( Math.abs(diff) > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " changed more than " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = ((tsvalue - tsvaluePrev)/tsvaluePrev)*100.0;
                if ( Math.abs(diff) > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat) +
                        " at " + date + " changed more than " +
                        value1 + "% since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff %=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( diff > value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " change is > " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.CHANGE_LESS_THAN ) {
            if ( (tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing ) {
                diff = tsvalue - tsvaluePrev;
                if ( diff < value1 ) {
                    message = "Time series " + tsid + " value " +
                        StringUtil.formatString(tsvalue,tsValueFormat)
                        + " at " + date + " change is < " +
                        value1 + " since previous value " +
                        StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" +
                        StringUtil.formatString(diff,tsValueFormat) + ")";
                    matchDetected = true;
                }
            }
        }
        else if ( checkCriteria == CheckType.EQUAL_TO ) {
            if ( !isMissing && (tsvalue == value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is = test value " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.GREATER_THAN ) {
            if ( !isMissing && (tsvalue > value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is > limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
            if ( !isMissing && (tsvalue >= value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is >= limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.IN_RANGE ) {
            if ( !isMissing && (tsvalue >= value1) && (tsvalue <= value2) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is in range " + value1 + " to " + value2;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.LESS_THAN ) {
            if ( !isMissing && (tsvalue < value1) ) {
                message = "Time series " + tsid + " value " +
                    StringUtil.formatString(tsvalue,tsValueFormat) +
                    " at " + date + " is < limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
            if ( !isMissing && (tsvalue <= value1) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is <= limit " + value1;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.MISSING ) {
            if ( isMissing ) {
                message = "Time series " + tsid + " value " + 
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is missing";
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.OUT_OF_RANGE ) {
            if ( !isMissing && (tsvalue < value1) || (tsvalue > value2) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " is out of range " + value1 + " to " + value2;
                matchDetected = true;
            }
        }
        else if ( checkCriteria == CheckType.REPEAT ) {
            if ( !isMissing && (tsvalueCount > 0) && !ts.isDataMissing(tsvalue) && !ts.isDataMissing(tsvalue) &&
                (tsvalue == tsvaluePrev) ) {
                message = "Time series " + tsid + " value " +
                StringUtil.formatString(tsvalue,tsValueFormat) +
                " at " + date + " repeated previous value";
                matchDetected = true;
            }
        }
        if ( message != null ) {
            // Add to the problems list
            __problems.add ( message );
            if ( __flag != null ) {
                // Update the flag value
                dataPoint = ts.getDataPoint(date, dataPoint );
                dataPoint.setDataFlag ( __flag );
                ts.setDataValue(date, dataPoint.getData(), dataPoint.getDataFlag(), dataPoint.getDuration() );
            }
        }
        // If an action is required, do it
        if ( matchDetected && (__action != null) )  {
            if ( __action.equalsIgnoreCase("Remove") ) {
                if ( ts instanceof IrregularTS ) {
                    // Remove the data point from memory
                    ((IrregularTS)ts).removeDataPoint(date);
                }
                else {
                    // Set to missing
                    ts.setDataValue(date, ts.getMissing() );
                }
            }
            else if ( __action.equalsIgnoreCase("SetMissing") ) {
                ts.setDataValue(date, ts.getMissing() );
            }
        }
        // Increment the count and save the previous value
        ++tsvalueCount;
        tsvaluePrev = tsvalue;
    }
    if ( (__flag != null) && !__flag.equals("") && (__problems.size() > 0) ) {
        // Remove leading + on flag, used to indicate concatenation
        String flag = StringUtil.remove(__flag,"+");
        if ( (__flagDesc == null) || __flagDesc.equals("") ) {
            // Default description...
            message = "Detected " + __problems.size() + " values where " + formatCriteriaForFlagDesc() + ".";
            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
        }
        else {
            // Use supplied description...
            message = "Detected " + __problems.size() + " values where " + __flagDesc + ".";
            ts.addDataFlagMetadata(new TSDataFlagMetadata( flag, message));
        }
        // Add a message to the genesis since flags have been set...
        ts.addToGenesis ( message + "  Set flag to " + flag + "." );
    }
}

/**
Format the criteria for use in output.
@return a string that describes the criteria, suitable for the flag description.
*/
private String formatCriteriaForFlagDesc ()
{
    if ( __checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
        return "abs(change(value)) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
        return "percent(abs(change(value))) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
        return "change(value) > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.CHANGE_LESS_THAN ) {
        return "change(value) < " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.IN_RANGE ) {
        return StringUtil.formatString(__checkValue1,"%.6f") + " <= value <= " +
            StringUtil.formatString(__checkValue2,"%.6f");
    }
    else if ( __checkCriteria == CheckType.OUT_OF_RANGE ) {
        return "value < " + StringUtil.formatString(__checkValue1,"%.6f") + " OR value > " +
        StringUtil.formatString(__checkValue2,"%.6f");
    }
    else if ( __checkCriteria == CheckType.MISSING ) {
        return "value is missing";
    }
    else if ( __checkCriteria == CheckType.REPEAT ) {
        return "value repeats previous value";
    }
    else if ( __checkCriteria == CheckType.LESS_THAN ) {
        return "value < " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
        return "value <= " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.GREATER_THAN ) {
        return "value > " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
        return "value >= " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else if ( __checkCriteria == CheckType.EQUAL_TO ) {
        return "value = " + StringUtil.formatString(__checkValue1,"%.6f");
    }
    else {
        throw new InvalidParameterException ( "Unrecognized check criteria \"" + __checkCriteria + "\"" );
    }
}

/**
Return the analysis end date/time.
@return the analysis end date/time.
*/
public DateTime getAnalysisEnd ()
{
    return __analysisEnd;
}

/**
Return the analysis start date/time.
@return the analysis start date/time.
*/
public DateTime getAnalysisStart ()
{
    return __analysisStart;
}

/**
Return the check type.
@return the check type.
*/
public CheckType getCheckCriteria ()
{
    return __checkCriteria;
}

/**
Get the list of check types that can be performed.
*/
public static List<CheckType> getCheckCriteriaChoices()
{
    List<CheckType> choices = new Vector();
    choices.add ( CheckType.ABS_CHANGE_GREATER_THAN );
    choices.add ( CheckType.ABS_CHANGE_PERCENT_GREATER_THAN );
    choices.add ( CheckType.CHANGE_GREATER_THAN );
    choices.add ( CheckType.CHANGE_LESS_THAN );
    choices.add ( CheckType.IN_RANGE );
    choices.add ( CheckType.OUT_OF_RANGE );
    choices.add ( CheckType.MISSING );
    choices.add ( CheckType.REPEAT );
    choices.add ( CheckType.LESS_THAN );
    choices.add ( CheckType.LESS_THAN_OR_EQUAL_TO );
    choices.add ( CheckType.GREATER_THAN );
    choices.add ( CheckType.GREATER_THAN_OR_EQUAL_TO );
    choices.add ( CheckType.EQUAL_TO );
    return choices;
}

/**
Get the list of statistics that can be performed.
@return the statistic display names as strings.
*/
public static List<String> getCheckCriteriaChoicesAsStrings()
{
    List<CheckType> choices = getCheckCriteriaChoices();
    List<String> stringChoices = new Vector();
    for ( int i = 0; i < choices.size(); i++ ) {
        stringChoices.add ( "" + choices.get(i) );
    }
    return stringChoices;
}

/**
Return the number of values that are required to evaluate a criteria.
@return the number of values that are required to evaluate a criteria.
@param checkCriteria the check criteria that is being evaluated.
*/
public static int getRequiredNumberOfValuesForCheckCriteria ( CheckType checkCriteria )
{
    // TODO SAM 2009-04-23 Need to convert to enumeration or something other than simple strings
    if ( checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.CHANGE_GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.CHANGE_LESS_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.GREATER_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.IN_RANGE ) {
        return 2;
    }
    else if ( checkCriteria == CheckType.LESS_THAN ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO ) {
        return 1;
    }
    else if ( checkCriteria == CheckType.MISSING ) {
        return 0;
    }
    else if ( checkCriteria == CheckType.OUT_OF_RANGE ) {
        return 2;
    }
    else if ( checkCriteria == CheckType.REPEAT ) {
        return 0;
    }
    else {
        String message = "Requested criteria is not recognized: " + checkCriteria;
        String routine = "TSUtil_CheckTimeSeries.getRequiredNumberOfValuesForCheckCriteria";
        Message.printWarning(3, routine, message);
        throw new InvalidParameterException ( message );
    }
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems ()
{
    return __problems;
}

/**
Return the time series being analyzed.
@return the time series being analyzed.
*/
public TS getTimeSeries ()
{
    return __ts;
}

/**
Return the first check constraint value.
@return the first check constraint value
*/
public Double getCheckValue1 ()
{
    return __checkValue1;
}

/**
Return the second check constraint value
@return the second check constraint value
*/
public Double getCheckValue2 ()
{
    return __checkValue2;
}

}