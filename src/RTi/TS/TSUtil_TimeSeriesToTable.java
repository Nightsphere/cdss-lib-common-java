package RTi.TS;

import java.util.List;
import java.util.Vector;

import RTi.Util.Message.Message;
import RTi.Util.Table.DataTable;
import RTi.Util.Time.DateTime;
import RTi.Util.Time.DateTimeWindow;

/**
Fill a table with time series values.
*/
public class TSUtil_TimeSeriesToTable
{

/**
List of problems generated by this command, guaranteed to be non-null.
*/
private List<String> __problems = new Vector();

/**
Data table being filled with time series.
*/
private DataTable __table = null;

/**
Time series to process.
*/
private List<TS> __tsList = null;

/**
Date/time column, 0+.
*/
private int __dateTimeColumn = -1;

/**
TSID column, 0+, for single-column output.
*/
private int __tableTSIDColumn = -1;

/**
TSID format, using time series %L, etc. specifiers.
*/
private String __tableTSIDFormat = null;

/**
When creating single column output, indicate whether missing values in time series should be transferred.
*/
private boolean __includeMissingValues = true;

/**
Data value columns for time series, 0+.
*/
private int [] __valueColumns = null;

/**
Data flag columns for time series, 0+.
*/
private int [] __flagColumns = null;

/**
First data row for time series, 0+.
*/
private int __dataRow = -1;

/**
Start of analysis (null to analyze all).
*/
private DateTime __outputStart = null;

/**
End of analysis (null to analyze all).
*/
private DateTime __outputEnd = null;

/**
Window within the year to transfer data values.
*/
private DateTimeWindow __outputWindow = null;

/**
Indicate whether missing values in time series should be transferred as null (true) or the
missing values transferred (false).
*/
private boolean __useNullForMissing = false;

/**
Constructor.
@param table Data table being filled with time series.  Column names need to have been defined but the
table is expected to be empty (no rows).
@param tslist list of time series being transferred to table.
@param dateTimeColumn date/time column (0+).
@param tableTSIDColumn name of column to contain TSID, for one-column output
@param tableTSIDFormat format of TSID corresponding to tableTSIDColumn
@param includeMissingValues indicates whether missing values should be output in single-column output (setting to
false can be advantageous when processing sparse time series)
@param valueColumns data columns (0+) corresponding to the correct column names for the time series; if a single column
is output, then the first array position will be used for each time series
@param dataRow table data row (0+) corresponding to first date/time to be transferred.
@param outputStart first date/time to be transferred (if null, output all)
@param outputEnd last date/time to be transferred (if null, output all)
@param outputWindow the window within a year to output (if null, output all)
@param useNullForMissing if true, use null in the table for missing values.  If false, transfer the
time series missing value indicator (e.g., -999 or NaN).  These values are not universally handled.
*/
public TSUtil_TimeSeriesToTable ( DataTable table, List<TS> tslist, int dateTimeColumn, int tableTSIDColumn,
    String tableTSIDFormat, boolean includeMissingValues, int [] valueColumns, int [] flagColumns,
    int dataRow, DateTime outputStart, DateTime outputEnd,
    DateTimeWindow outputWindow, boolean useNullForMissing )
{   __table = table;
    __tsList = tslist;
    __dateTimeColumn = dateTimeColumn;
    __tableTSIDColumn = tableTSIDColumn;
    __tableTSIDFormat = tableTSIDFormat;
    __includeMissingValues = includeMissingValues;
    __valueColumns = valueColumns;
    __flagColumns = flagColumns;
    __dataRow = dataRow;
    __outputStart = outputStart;
    __outputEnd = outputEnd;
    __outputWindow = outputWindow; // Allow null to speed performance checks
    __useNullForMissing = useNullForMissing;
    // Make sure that the time series are regular and of the same interval if multi-column
    if ( (tslist.size() > 0) && (tableTSIDColumn < 0) ) {
        if ( !TSUtil.intervalsMatch(tslist) ) {
            throw new UnequalTimeIntervalException (
                "Time series don't have the same interval - cannot convert to multi-column table.");
        }
        if ( TSUtil.areAnyTimeSeriesIrregular(tslist) ) {
            throw new IrregularTimeSeriesNotSupportedException (
                "Irregular time series cannot be converted to a multi-column table.");
        }
    }
}

/**
Copy the time series into the table.
*/
public void timeSeriesToTable ()
{   String routine = getClass().getName() + ".timeSeriesToTable";
    // Create a new list of problems
    __problems = new Vector();
    

    if ( __tableTSIDColumn >= 0 ) {
        // Outputting single column table
        // Iterate through each time series and dump the values within the requested range
        TSIterator tsi = null;
        int valueColumn = __valueColumns[0];
        int flagColumn = -1;
        if ( (__flagColumns != null) && (__flagColumns.length == 1) ) {
            flagColumn = __flagColumns[0];
        }
        int setRow;
        int rowCount = -1; // Will align properly when incremented below
        for ( TS ts : __tsList ) {
            if ( ts == null ) {
                continue;
            }
            try {
                tsi = ts.iterator(__outputStart,__outputEnd);
            }
            catch ( Exception e ) {
                Message.printWarning(3,routine,"Error initializing iterator for " +
                     ts.getIdentifier().toStringAliasAndTSID() + " (" + e + ")" );
                continue;
            }
            TSData tsdata;
            DateTime date;
            double value;
            String flag;
            String tsid;
            boolean isMissing;
            while ( (tsdata = tsi.next()) != null ) {
                // Set the date
                date = tsdata.getDate();
                if ( (__outputWindow != null) && !__outputWindow.isDateTimeInWindow(date) ) {
                    // Don't add the row...
                    continue;
                }
                // Check for missing
                value = tsdata.getDataValue();
                isMissing = false;
                if ( ts.isDataMissing(value) ) {
                    isMissing = true;
                }
                if ( isMissing && !__includeMissingValues ) {
                    // Don't want to include missing values
                    continue;
                }
                // Row is incremented for each value, but only after above checks
                ++rowCount;
                setRow = __dataRow + rowCount;
                // Set the date/time
                try {
                    __table.setFieldValue(setRow, __dateTimeColumn, new DateTime(date), true );
                }
                catch ( Exception e ) {
                    __problems.add ( "Error setting date " + date + " for row [" + setRow + "] (" + e + ").");
                }
                // Set the TSID
                if ( __tableTSIDFormat == null ) {
                    // Use the alias if available, otherwise the TSID
                    String alias = ts.getAlias();
                    if ( (alias != null) && !alias.equals("") ) {
                        tsid = alias;
                    }
                    else {
                        tsid = ts.getIdentifier().toString();
                    }
                }
                else {
                    tsid = ts.formatExtendedLegend(__tableTSIDFormat);
                }
                try {
                    __table.setFieldValue(setRow, __tableTSIDColumn, tsid, true );
                }
                catch ( Exception e ) {
                    __problems.add ( "Error setting TSID " + tsid + " for row [" + setRow + "] (" + e + ").");
                }
                // Set the data value and optionally the flag
                try {
                    if ( isMissing && __useNullForMissing ) {
                        __table.setFieldValue(setRow, valueColumn, null, true );
                    }
                    else {
                        // Set as a double because non-missing or missing and the missing value should be used
                        __table.setFieldValue(setRow, valueColumn, new Double(value), true );
                    }
                }
                catch ( Exception e ) {
                    __problems.add ( "Error setting data value " + value +
                        " at " + date + " [" + setRow + "][" + valueColumn + "] (" + e + ").");
                }
                if ( flagColumn >= 0 ) {
                    // Column has been specified for flag so output
                    flag = tsdata.getDataFlag();
                    if ( flag == null ) {
                        flag = "";
                    }
                    try {
                        __table.setFieldValue(setRow, flagColumn, flag, true );
                    }
                    catch ( Exception e ) {
                        __problems.add ( "Error setting data flag " + flag +
                            " at " + date + " [" + setRow + "][" + flagColumn + "] (" + e + ").");
                    }
                }
            }
        }
    }
    else {
        // Outputting a multi-column tables where the date/time column is used for all the time series
        // If the output start and end are not specified, use the maximum period
        if ( (__outputStart == null) || (__outputEnd == null) ) {
            // One or more of the requested dates is null so find the full period of the data
            TSLimits limits = null;
            try {
                limits = TSUtil.getPeriodFromTS(__tsList, TSUtil.MAX_POR );
                if ( __outputStart == null ) {
                    __outputStart = new DateTime(limits.getDate1());
                }
                if ( __outputEnd == null ) {
                    __outputEnd = new DateTime(limits.getDate2());
                }
            }
            catch ( Exception e ) {
                // Worst case use the period from the first time series
                __outputStart = __tsList.get(0).getDate1();
                __outputEnd = __tsList.get(0).getDate2();
            }
        }
        // Iterate through the dates
        int its; // iterator for time series
        TS ts; // time series being processed
        int tsListSize = __tsList.size();
        int intervalBase = __tsList.get(0).getDataIntervalBase();
        int intervalMult = __tsList.get(0).getDataIntervalMult();
        int rowCount = 0;
        int setRow, setColumn; // Row and column for data set
        double value; // Data value from time series
        DateTime date = null;
        for (date = new DateTime(__outputStart); date.lessThanOrEqualTo(__outputEnd);
            date.addInterval(intervalBase,intervalMult) ) {
            if ( (__outputWindow != null) && !__outputWindow.isDateTimeInWindow(date) ) {
                // Don't add the row...
                continue;
            }
            // Set the date/time
            setRow = __dataRow + rowCount;
            try {
                __table.setFieldValue(setRow, __dateTimeColumn, new DateTime(date), true );
            }
            catch ( Exception e ) {
                __problems.add ( "Error setting date " + date + " for row [" + setRow + "] (" + e + ").");
            }
            // Iterate through the time series
            for ( its = 0; its < tsListSize; its++ ) {
                ts = __tsList.get(its);
                value = ts.getDataValue(date);
                // Each time series is in a separate column
                setColumn = __valueColumns[its];
                try {
                    if ( ts.isDataMissing(value) && __useNullForMissing ) {
                        __table.setFieldValue(setRow, setColumn, null, true );
                    }
                    else {
                        // Set as a double because non-missing or missing and the missing value should be used
                        __table.setFieldValue(setRow, setColumn, new Double(value), true );
                    }
                }
                catch ( Exception e ) {
                    __problems.add ( "Error setting data value " + value +
                        " at " + date + " [" + setRow + "][" + setColumn + "] (" + e + ").");
                }
            }
            // If here the row was added so increment for the next add
            ++rowCount;
        }
    }
}

/**
Return the output end date/time.
@return the output end date/time.
*/
public DateTime getOutputEnd ()
{
    return __outputEnd;
}

/**
Return the output start date/time.
@return the output start date/time.
*/
public DateTime getOutputStart ()
{
    return __outputStart;
}

/**
Return the output window.
@return the output window.
*/
public DateTimeWindow getOutputWindow ()
{
    return __outputWindow;
}

/**
Return a list of problems for the time series.
*/
public List<String> getProblems ()
{
    return __problems;
}

/**
Return the time series being analyzed.
@return the time series being analyzed.
*/
public List<TS> getTimeSeriesList ()
{
    return __tsList;
}

}