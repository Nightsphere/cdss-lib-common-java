// Decompiled by DJ v3.9.9.91 Copyright 2005 Atanas Neshkov  Date: 4/25/2006 17:42:26
// Home Page : http://members.fortunecity.com/neshkov/dj.html  - Check often for new version!
// Decompiler options: packimports(3) 
// Source File Name:   DataTest.java

package RTi.DataTest;

import RTi.TS.TS;
import RTi.Util.IO.IOUtil;
import RTi.Util.IO.PropList;
import RTi.Util.Time.*;
import java.io.PrintStream;
import java.util.Vector;

// Referenced classes of package RTi.DataTest:
//            DataTestExpression, Action, DataTestFunction, DataTestDataModel, 
//            DataTestResult, DataTestSideFactory, DataTest_Util

public class DataTest
{

    public DataTest()
    {
        __actions = null;
        __isActive = false;
        __isMaster = false;
        __wasLastTestPositive = false;
        __expression = null;
        __activeSeasonEnd = null;
        __activeSeasonStart = null;
        __evaluationEnd = null;
        __evaluationStart = null;
        __lastTestDateTime = null;
        __nextTestDateTime = null;
        __testBaseTime = null;
        __activeSeasonFormat = null;
        __testBaseTimeFormat = null;
        __actionNums = null;
        __dataTestExpressionNum = -999;
        __dataTestGroupNum = -999;
        __dataTestStatusNum = -999;
        __testNum = -999;
        __positiveCount = -999;
        __description = "";
        __id = "";
        __message = "";
        __properties = null;
        __evaluationInterval = null;
        __evaluationWindow = null;
        __positiveTestInterval = null;
        __testInterval = null;
        __dataTests = null;
        __results = new Vector();
    }

    public DataTest(DataTestDataModel model)
        throws Exception
    {
        __actions = null;
        __isActive = false;
        __isMaster = false;
        __wasLastTestPositive = false;
        __expression = null;
        __activeSeasonEnd = null;
        __activeSeasonStart = null;
        __evaluationEnd = null;
        __evaluationStart = null;
        __lastTestDateTime = null;
        __nextTestDateTime = null;
        __testBaseTime = null;
        __activeSeasonFormat = null;
        __testBaseTimeFormat = null;
        __actionNums = null;
        __dataTestExpressionNum = -999;
        __dataTestGroupNum = -999;
        __dataTestStatusNum = -999;
        __testNum = -999;
        __positiveCount = -999;
        __description = "";
        __id = "";
        __message = "";
        __properties = null;
        __evaluationInterval = null;
        __evaluationWindow = null;
        __positiveTestInterval = null;
        __testInterval = null;
        __dataTests = null;
        __results = new Vector();
        transferValuesFromDataModel(model);
        __expression = (DataTestExpression)DataTestSideFactory.getDataTestSide(1, getDataTestExpressionNum());
    }

    public DataTest(DataTest dt)
    {
        __actions = null;
        __isActive = false;
        __isMaster = false;
        __wasLastTestPositive = false;
        __expression = null;
        __activeSeasonEnd = null;
        __activeSeasonStart = null;
        __evaluationEnd = null;
        __evaluationStart = null;
        __lastTestDateTime = null;
        __nextTestDateTime = null;
        __testBaseTime = null;
        __activeSeasonFormat = null;
        __testBaseTimeFormat = null;
        __actionNums = null;
        __dataTestExpressionNum = -999;
        __dataTestGroupNum = -999;
        __dataTestStatusNum = -999;
        __testNum = -999;
        __positiveCount = -999;
        __description = "";
        __id = "";
        __message = "";
        __properties = null;
        __evaluationInterval = null;
        __evaluationWindow = null;
        __positiveTestInterval = null;
        __testInterval = null;
        __dataTests = null;
        __results = new Vector();
        if(dt.__actions != null)
        {
            __actions = new Action[dt.__actions.length];
            for(int i = 0; i < dt.__actions.length; i++)
                __actions[i] = dt.__actions[i];

        }
        __isActive = dt.__isActive;
        __expression = DataTest_Util.copyExpression(dt.__expression);
        if(dt.__activeSeasonEnd != null)
            __activeSeasonEnd = new DateTime(dt.__activeSeasonEnd);
        if(dt.__activeSeasonStart != null)
            __activeSeasonStart = new DateTime(dt.__activeSeasonStart);
        if(dt.__evaluationEnd != null)
            __evaluationEnd = new DateTime(dt.__evaluationEnd);
        if(dt.__evaluationStart != null)
            __evaluationStart = new DateTime(dt.__evaluationStart);
        if(dt.__testBaseTime != null)
            __testBaseTime = new DateTime(dt.__testBaseTime);
        if(dt.__activeSeasonFormat != null)
            __activeSeasonFormat = new DateTimeFormat(dt.__activeSeasonFormat);
        if(dt.__testBaseTimeFormat != null)
            __testBaseTimeFormat = new DateTimeFormat(dt.__testBaseTimeFormat);
        if(dt.__actionNums != null)
        {
            __actionNums = new int[dt.__actionNums.length];
            for(int i = 0; i < dt.__actionNums.length; i++)
                __actionNums[i] = dt.__actionNums[i];

        }
        __dataTestExpressionNum = dt.__dataTestExpressionNum;
        __dataTestGroupNum = dt.__dataTestGroupNum;
        __dataTestStatusNum = dt.__dataTestStatusNum;
        __testNum = dt.__testNum;
        __positiveCount = dt.__positiveCount;
        __description = dt.__description;
        __id = dt.__id;
        __message = dt.__message;
        if(dt.__properties != null)
            __properties = new PropList(dt.__properties);
        if(dt.__evaluationInterval != null)
            __evaluationInterval = new TimeInterval(dt.__evaluationInterval);
        if(dt.__evaluationWindow != null)
            __evaluationWindow = new TimeInterval(dt.__evaluationWindow);
        if(dt.__positiveTestInterval != null)
            __positiveTestInterval = new TimeInterval(dt.__positiveTestInterval);
        if(dt.__testInterval != null)
            __testInterval = new TimeInterval(dt.__testInterval);
    }

    public void checkRealtimeData()
        throws Exception
    {
        String s = "";
        int count = 0;
        if(getTestBaseTime() == null)
        {
            s = s + "TestBaseTime";
            count++;
        }
        if(getTestBaseTimeFormat() == null)
        {
            if(count > 0)
                s = s + ", ";
            s = s + "TestBaseTimeFormat";
            count++;
        }
        if(getEvaluationWindow() == null)
        {
            if(count > 0)
                s = s + ", ";
            s = s + "EvaluationWindow";
            count++;
        }
        if(count > 0)
            throw new Exception("The following data members must be set if this test is to run in a real-time system: " + s);
        else
            return;
    }

    public boolean checkTimeSeriesForSameIntervals()
    {
        return checkTimeSeriesForSameIntervalsHelper(getDataTestExpression()) != null;
    }

    private int[] checkTimeSeriesForSameIntervalsHelper(DataTestExpression expr)
    {
        int baseMult[] = null;
        int lbase = -1;
        int lmult = -1;
        int numTS = 0;
        int rbase = -1;
        int rmult = -1;
        int tempBase = -1;
        int tempMult = -1;
        TS ts = null;
        if(expr.getLeftSideType() == 1)
        {
            baseMult = checkTimeSeriesForSameIntervalsHelper((DataTestExpression)expr.getLeftSide());
            if(baseMult != null)
            {
                lbase = baseMult[0];
                lmult = baseMult[1];
            } else
            {
                lbase = -999;
                lmult = -999;
            }
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            if(numTS > 0)
            {
                baseMult = checkFunctionTimeSeriesForSameIntervals((DataTestFunction)expr.getLeftSide());
                if(baseMult == null)
                {
                    lbase = -999;
                    rbase = -999;
                } else
                {
                    lbase = baseMult[0];
                    lmult = baseMult[1];
                }
            } else
            {
                lbase = -1;
                lmult = -1;
            }
        }
        if(expr.getRightSideType() == 1)
        {
            baseMult = checkTimeSeriesForSameIntervalsHelper((DataTestExpression)expr.getRightSide());
            if(baseMult != null)
            {
                rbase = baseMult[0];
                rmult = baseMult[1];
            } else
            {
                rbase = -999;
                rmult = -999;
            }
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            if(numTS > 0)
            {
                baseMult = checkFunctionTimeSeriesForSameIntervals((DataTestFunction)expr.getRightSide());
                if(baseMult == null)
                {
                    lbase = -999;
                    rbase = -999;
                } else
                {
                    lbase = baseMult[0];
                    lmult = baseMult[1];
                }
            } else
            {
                rbase = -1;
                rmult = -1;
            }
        }
        if(rbase == -999 || rmult == -999 || lbase == -999 || lmult == -999)
            return null;
        if(rbase == -1 && lbase != -1)
            rbase = lbase;
        else
        if(rbase != -1 && lbase == -1)
            rbase = rbase;
        else
        if(rbase != lbase)
            return null;
        if(rmult == -1 && lmult != -1)
            rmult = lmult;
        else
        if(rmult != -1 && lmult == -1)
            rmult = rmult;
        if(rmult != lmult)
        {
            return null;
        } else
        {
            baseMult = new int[2];
            baseMult[0] = rbase;
            baseMult[1] = rmult;
            return baseMult;
        }
    }

    private int[] checkFunctionTimeSeriesForSameIntervals(DataTestFunction function)
    {
        int numTS = function.getNumTS();
        TS ts = function.getTS(0);
        int base = ts.getDataIntervalBase();
        int mult = ts.getDataIntervalMult();
        int baseMult[] = {
            base, mult
        };
        for(int i = 1; i < numTS; i++)
        {
            ts = function.getTS(1);
            if(base != ts.getDataIntervalBase())
                return null;
            if(mult != ts.getDataIntervalMult())
                return null;
        }

        return baseMult;
    }

    public void connectActions(Vector actions)
    {
        Action action = null;
        int size = actions.size();
        Vector v = new Vector();
        for(int i = 0; i < size; i++)
        {
            action = (Action)actions.elementAt(i);
            for(int j = 0; j < __actionNums.length; j++)
                if(action.getActionNum() == __actionNums[j])
                    v.add(action);

        }

        size = v.size();
        __actions = new Action[size];
        for(int i = 0; i < size; i++)
            __actions[i] = (Action)v.elementAt(i);

        v.clear();
    }

    public void finalize()
        throws Throwable
    {
        IOUtil.nullArray(__actions);
        __activeSeasonEnd = null;
        __activeSeasonStart = null;
        __description = null;
        __expression = null;
        __id = null;
        __lastTestDateTime = null;
        __nextTestDateTime = null;
        __message = null;
        __properties = null;
        __evaluationInterval = null;
        __evaluationWindow = null;
        __evaluationStart = null;
        __evaluationEnd = null;
        __positiveTestInterval = null;
        __testBaseTime = null;
        __testInterval = null;
        __activeSeasonFormat = null;
        __testBaseTimeFormat = null;
        __actionNums = null;
        __dataTests = null;
        __results = null;
        super.finalize();
    }

    public int[] getTimeSeriesIntervalData()
    {
        int baseMult[] = getTimeSeriesIntervalDataHelper(getDataTestExpression());
        if(baseMult == null)
        {
            baseMult = new int[2];
            baseMult[0] = -1;
            baseMult[1] = -1;
        }
        return baseMult;
    }

    private int[] getTimeSeriesIntervalDataHelper(DataTestExpression expr)
    {
        int lbaseMult[] = null;
        int rbaseMult[] = null;
        int numTS = 0;
        TS ts = null;
        if(expr.getLeftSideType() == 1)
        {
            lbaseMult = getTimeSeriesIntervalDataHelper((DataTestExpression)expr.getLeftSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            if(numTS > 0)
            {
                ts = ((DataTestFunction)expr.getLeftSide()).getTS(0);
                lbaseMult = new int[2];
                lbaseMult[0] = ts.getDataIntervalBase();
                lbaseMult[1] = ts.getDataIntervalMult();
            } else
            {
                lbaseMult = null;
            }
        }
        if(expr.getRightSideType() == 1)
        {
            rbaseMult = getTimeSeriesIntervalDataHelper((DataTestExpression)expr.getRightSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            if(numTS > 0)
            {
                ts = ((DataTestFunction)expr.getRightSide()).getTS(0);
                rbaseMult = new int[2];
                rbaseMult[0] = ts.getDataIntervalBase();
                rbaseMult[1] = ts.getDataIntervalMult();
            } else
            {
                rbaseMult = null;
            }
        }
        if(rbaseMult != null)
            return rbaseMult;
        if(lbaseMult != null)
            return lbaseMult;
        else
            return null;
    }

    public DateTime getEndDate()
    {
        return getEndDateHelper(getDataTestExpression());
    }

    private DateTime getEndDateHelper(DataTestExpression expr)
    {
        DateTime left = null;
        DateTime right = null;
        int numTS = 0;
        TS ts = null;
        if(expr.getLeftSideType() == 1)
        {
            left = getEndDateHelper((DataTestExpression)expr.getLeftSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            if(numTS > 0)
                left = getEndDateHelper((DataTestFunction)expr.getLeftSide());
        }
        if(expr.getRightSideType() == 1)
        {
            right = getEndDateHelper((DataTestExpression)expr.getRightSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            if(numTS > 0)
                right = getEndDateHelper((DataTestFunction)expr.getRightSide());
        }
        if(left == null && right == null)
            return null;
        if(left == null)
            return right;
        if(right == null)
            return left;
        if(left.greaterThan(right))
            return left;
        else
            return right;
    }

    private DateTime getEndDateHelper(DataTestFunction func)
    {
        int numTS = func.getNumTS();
        TS ts = func.getTS(0);
        DateTime end = ts.getDate2();
        for(int i = 1; i < numTS; i++)
        {
            ts = func.getTS(i);
            if(ts.getDate2().lessThan(end))
                end = ts.getDate2();
        }

        return end;
    }

    public DateTime getStartDate()
    {
        return getStartDateHelper(getDataTestExpression());
    }

    private DateTime getStartDateHelper(DataTestExpression expr)
    {
        DateTime left = null;
        DateTime right = null;
        int numTS = 0;
        TS ts = null;
        if(expr.getLeftSideType() == 1)
        {
            left = getStartDateHelper((DataTestExpression)expr.getLeftSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            if(numTS > 0)
                left = getStartDateHelper((DataTestFunction)expr.getLeftSide());
        }
        if(expr.getRightSideType() == 1)
        {
            right = getStartDateHelper((DataTestExpression)expr.getRightSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            if(numTS > 0)
                right = getStartDateHelper((DataTestFunction)expr.getRightSide());
        }
        if(left == null && right == null)
            return null;
        if(left == null)
            return right;
        if(right == null)
            return left;
        if(left.lessThan(right))
            return left;
        else
            return right;
    }

    private DateTime getStartDateHelper(DataTestFunction func)
    {
        int numTS = func.getNumTS();
        TS ts = func.getTS(0);
        DateTime end = ts.getDate1();
        for(int i = 1; i < numTS; i++)
        {
            ts = func.getTS(i);
            if(ts.getDate1().lessThan(end))
                end = ts.getDate1();
        }

        return end;
    }

    public Vector getWildcardTSIDs()
    {
        return getWildcardTSIDsHelper(getDataTestExpression());
    }

    private Vector getWildcardTSIDsHelper(DataTestExpression expr)
    {
        int numTS = -1;
        Vector left = null;
        Vector right = null;
        if(expr.getLeftSideType() == 1)
        {
            left = getWildcardTSIDsHelper((DataTestExpression)expr.getLeftSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            if(numTS > 0)
                left = getWildcardTSIDsHelper((DataTestFunction)expr.getLeftSide());
        }
        if(expr.getRightSideType() == 1)
        {
            right = getWildcardTSIDsHelper((DataTestExpression)expr.getRightSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            if(numTS > 0)
                right = getWildcardTSIDsHelper((DataTestFunction)expr.getRightSide());
        }
        Vector both = null;
        int size = -1;
        if(left != null || right != null)
            both = new Vector();
        if(left != null)
        {
            size = left.size();
            for(int i = 0; i < size; i++)
                both.add(left.elementAt(i));

        }
        if(right != null)
        {
            size = right.size();
            for(int i = 0; i < size; i++)
                both.add(right.elementAt(i));

        }
        return both;
    }

    private Vector getWildcardTSIDsHelper(DataTestFunction func)
    {
        Vector v = new Vector();
        int tsidPositions[] = func.getTSIDPositions();
        if(tsidPositions == null)
            return null;
        for(int i = 0; i < tsidPositions.length; i++)
            if(func.getInputDataID(tsidPositions[i]).indexOf("*") > -1)
                v.add(func.getInputDataID(tsidPositions[i]));

        return v;
    }

    public Action[] getActions()
    {
        return __actions;
    }

    public int[] getActionNums()
    {
        if(__actions == null)
            return new int[0];
        int size = __actions.length;
        int arr[] = new int[size];
        Action action = null;
        for(int i = 0; i < size; i++)
            arr[i] = __actions[i].getActionNum();

        return arr;
    }

    public DateTime getActiveSeasonEnd()
    {
        return __activeSeasonEnd;
    }

    public DateTimeFormat getActiveSeasonFormat()
    {
        return __activeSeasonFormat;
    }

    public DateTime getActiveSeasonStart()
    {
        return __activeSeasonStart;
    }

    public Vector getDataTests()
    {
        return __dataTests;
    }

    public DataTestExpression getDataTestExpression()
    {
        return __expression;
    }

    public int getDataTestExpressionNum()
    {
        return __dataTestExpressionNum;
    }

    public int getDataTestGroupNum()
    {
        return __dataTestGroupNum;
    }

    public int getDataTestStatusNum()
    {
        return __dataTestStatusNum;
    }

    public String getDescription()
    {
        return __description;
    }

    public DateTime getEvaluationEnd()
    {
        return __evaluationEnd;
    }

    public TimeInterval getEvaluationInterval()
    {
        return __evaluationInterval;
    }

    public DateTime getEvaluationStart()
    {
        return __evaluationStart;
    }

    public TimeInterval getEvaluationWindow()
    {
        return __evaluationWindow;
    }

    public String getID()
    {
        return __id;
    }

    public DateTime getLastTestDateTime()
    {
        return __lastTestDateTime;
    }

    public DateTime getNextTestDateTime()
    {
        return __nextTestDateTime;
    }

    public int getTestNum()
    {
        return __testNum;
    }

    public String getMessage()
    {
        return __message;
    }

    public int getPositiveCount()
    {
        return __positiveCount;
    }

    public TimeInterval getPositiveTestInterval()
    {
        return __positiveTestInterval;
    }

    public PropList getProperties()
    {
        return __properties;
    }

    public DateTime getTestBaseTime()
    {
        return __testBaseTime;
    }

    public DateTimeFormat getTestBaseTimeFormat()
    {
        return __testBaseTimeFormat;
    }

    public TimeInterval getTestInterval()
    {
        return __testInterval;
    }

    public boolean hasWildcards()
    {
        return hasWildcardsHelper(getDataTestExpression());
    }

    private boolean hasWildcardsHelper(DataTestExpression expr)
    {
        int numTS = -1;
        boolean left = false;
        boolean right = false;
        if(expr.getLeftSideType() == 1)
        {
            left = hasWildcardsHelper((DataTestExpression)expr.getLeftSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            if(numTS > 0)
                left = hasWildcardsHelper((DataTestFunction)expr.getLeftSide());
        }
        if(expr.getRightSideType() == 1)
        {
            right = hasWildcardsHelper((DataTestExpression)expr.getRightSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            if(numTS > 0)
                right = hasWildcardsHelper((DataTestFunction)expr.getRightSide());
        }
        return left || right;
    }

    private boolean hasWildcardsHelper(DataTestFunction func)
    {
        int tsidPositions[] = func.getTSIDPositions();
        if(tsidPositions == null)
            return false;
        for(int i = 0; i < tsidPositions.length; i++)
            if(func.getInputDataID(tsidPositions[i]).indexOf("*") > -1)
                return true;

        return false;
    }

    public boolean isActive()
    {
        return __isActive;
    }

    public boolean isInActiveSeason(DateTime dt)
    {
        if(__activeSeasonEnd == null || __activeSeasonStart == null)
            return true;
        __activeSeasonFormat.fillRelativeDateTime(__activeSeasonEnd, dt);
        __activeSeasonFormat.fillRelativeDateTime(__activeSeasonStart, dt);
        if(__activeSeasonEnd.lessThan(__activeSeasonStart))
            __activeSeasonFormat.iterateRelativeDateTime(__activeSeasonEnd);
        return dt.lessThanOrEqualTo(__activeSeasonEnd) && dt.greaterThanOrEqualTo(__activeSeasonStart);
    }

    public boolean isMaster()
    {
        return __isMaster;
    }

    public boolean isTimeToRun(DateTime currentDate)
    {
        DateTime runDate = null;
        DateTime nextDate = getNextTestDateTime();
        if(nextDate != null && currentDate.greaterThanOrEqualTo(nextDate))
            return true;
        if(nextDate == null)
        {
            DateTime testBaseTime = new DateTime(getTestBaseTime());
            DateTimeFormat format = getTestBaseTimeFormat();
            format.fillRelativeDateTime(testBaseTime, currentDate);
            return currentDate.greaterThanOrEqualTo(testBaseTime);
        } else
        {
            return false;
        }
    }

    public boolean runInterval(DateTime currentDate)
    {
        preTestRun();
        setTestData();
        DateTime runDate = new DateTime(currentDate);
        TimeInterval interval = getEvaluationWindow();
        runDate.subtractInterval(interval.getBase(), interval.getMultiplier());
        int baseMult[] = getTimeSeriesIntervalData();
        runDate = trimToActiveSeasonStart(runDate);
        DateTime endDate = new DateTime(currentDate);
        for(endDate = trimToActiveSeasonEnd(endDate); runDate.lessThanOrEqualTo(endDate); runDate.addInterval(baseMult[0], baseMult[1]))
        {
            System.out.println("    -- " + runDate);
            run(runDate);
        }

        postTestRun();
        return true;
    }

    /**
     * @deprecated Method runTest is deprecated
     */

    public boolean runTest(DateTime dt)
    {
        return run(dt);
    }

    public boolean run(DateTime dt)
    {
        Vector results = new Vector();
        if(__expression.evaluate(dt) != 0.0D)
        {
            __expression.evaluatePositiveResult(this, results, dt, 0);
            if(__actions != null)
            {
                for(int i = 0; i < __actions.length; i++)
                    __actions[i].addResults(results);

            }
            __results.add(results);
            return true;
        } else
        {
            results = null;
            return false;
        }
    }

    public void setActionNums(int actionIDs[])
    {
        __actionNums = actionIDs;
    }

    public void setActiveSeasonEnd(DateTime activeSeasonEnd)
    {
        __activeSeasonEnd = activeSeasonEnd;
    }

    public void setActiveSeasonFormat(DateTimeFormat activeSeasonFormat)
    {
        __activeSeasonFormat = activeSeasonFormat;
    }

    public void setActiveSeasonStart(DateTime activeSeasonStart)
    {
        __activeSeasonStart = activeSeasonStart;
    }

    public void setDataTests(Vector dataTests)
    {
        __dataTests = dataTests;
    }

    public void setDataTestExpression(DataTestExpression expression)
    {
        __expression = expression;
    }

    public void setDataTestExpressionNum(int dataTestExpressionNum)
    {
        __dataTestExpressionNum = dataTestExpressionNum;
    }

    public void setDataTestGroupNum(int dataTestGroupNum)
    {
        __dataTestGroupNum = dataTestGroupNum;
    }

    public void setDataTestStatusNum(int dataTestStatusNum)
    {
        __dataTestStatusNum = dataTestStatusNum;
    }

    public void setDescription(String description)
    {
        __description = description;
    }

    public void setEvaluationEnd(DateTime evaluationEnd)
    {
        __evaluationEnd = evaluationEnd;
    }

    public void setEvaluationInterval(TimeInterval evaluationInterval)
    {
        __evaluationInterval = evaluationInterval;
    }

    public void setEvaluationStart(DateTime evaluationStart)
    {
        __evaluationStart = evaluationStart;
    }

    public void setEvaluationWindow(TimeInterval evaluationWindow)
    {
        __evaluationWindow = evaluationWindow;
    }

    public void setID(String id)
    {
        __id = id;
    }

    public void setIsMaster(boolean isMaster)
    {
        __isMaster = isMaster;
    }

    public void setTestNum(int testNum)
    {
        __testNum = testNum;
    }

    public void setIsActive(boolean isActive)
    {
        __isActive = isActive;
    }

    public void setLastTestDateTime(DateTime lastTestDateTime)
    {
        __lastTestDateTime = lastTestDateTime;
    }

    public void setNextTestDateTime(DateTime nextTestDateTime)
    {
        __nextTestDateTime = nextTestDateTime;
    }

    public void setMessage(String message)
    {
        __message = message;
    }

    public void setPositiveCount(int positiveCount)
    {
        __positiveCount = positiveCount;
    }

    public void setPositiveTestInterval(TimeInterval positiveTestInterval)
    {
        __positiveTestInterval = positiveTestInterval;
    }

    public void setProperties(PropList properties)
    {
        __properties = properties;
    }

    public void setTestBaseTime(DateTime testBaseTime)
    {
        __testBaseTime = testBaseTime;
    }

    public void setTestBaseTimeFormat(DateTimeFormat testBaseTimeFormat)
    {
        __testBaseTimeFormat = testBaseTimeFormat;
    }

    public void setTestInterval(TimeInterval testInterval)
    {
        __testInterval = testInterval;
    }

    public void setWasLastTestPositive(boolean wasLastTestPositive)
    {
        __wasLastTestPositive = wasLastTestPositive;
    }

    public void setWildcards(String tsid)
    {
        setWildcardsHelper(getDataTestExpression(), tsid);
    }

    private void setWildcardsHelper(DataTestExpression expr, String tsid)
    {
        int numTS = -1;
        if(expr.getLeftSideType() == 1)
        {
            setWildcardsHelper((DataTestExpression)expr.getLeftSide(), tsid);
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            if(numTS > 0)
                setWildcardsHelper((DataTestFunction)expr.getLeftSide(), tsid);
        }
        if(expr.getRightSideType() == 1)
        {
            setWildcardsHelper((DataTestExpression)expr.getRightSide(), tsid);
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            if(numTS > 0)
                setWildcardsHelper((DataTestFunction)expr.getRightSide(), tsid);
        }
    }

    private void setWildcardsHelper(DataTestFunction func, String tsid)
    {
        int tsidPositions[] = func.getTSIDPositions();
        if(tsidPositions == null)
            return;
        for(int i = 0; i < tsidPositions.length; i++)
            if(func.getInputDataID(tsidPositions[i]).indexOf("*") > -1)
                func.setInputDataID(tsid, tsidPositions[i]);

    }

    public void setTestData()
    {
        setTestDataHelper(getDataTestExpression());
    }

    private void setTestDataHelper(DataTestExpression expr)
    {
        int numTS = -1;
        if(expr.getLeftSideType() == 1)
        {
            setTestDataHelper((DataTestExpression)expr.getLeftSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getLeftSide()).getNumTS();
            ((DataTestFunction)expr.getLeftSide()).setTestData();
        }
        if(expr.getRightSideType() == 1)
        {
            setTestDataHelper((DataTestExpression)expr.getRightSide());
        } else
        {
            numTS = ((DataTestFunction)expr.getRightSide()).getNumTS();
            ((DataTestFunction)expr.getRightSide()).setTestData();
        }
    }

    public DataTestDataModel toDataModel()
    {
        DataTestDataModel model = new DataTestDataModel();
        if(getActiveSeasonFormat() != null)
        {
            model.setActiveSeasonEnd(getActiveSeasonFormat().format(getActiveSeasonEnd()));
            model.setActiveSeasonStart(getActiveSeasonFormat().format(getActiveSeasonStart()));
        }
        model.setActiveSeasonFormat(getActiveSeasonFormat());
        model.setActionNums(getActionNums());
        model.setDataTestExpressionNum(getDataTestExpressionNum());
        model.setDataTestGroupNum(getDataTestGroupNum());
        model.setDataTestStatusNum(getDataTestStatusNum());
        model.setDescription(getDescription());
        model.setEvaluationEnd(getEvaluationEnd());
        model.setEvaluationStart(getEvaluationStart());
        model.setEvaluationInterval(getEvaluationInterval());
        model.setEvaluationWindow(getEvaluationWindow());
        model.setTestNum(getTestNum());
        model.setIsActive(isActive());
        model.setMessage(getMessage());
        model.setPositiveCount(getPositiveCount());
        model.setPositiveTestInterval(getPositiveTestInterval());
        model.setProperties(getProperties());
        if(getTestBaseTimeFormat() != null)
            model.setTestBaseTime(getTestBaseTimeFormat().format(getTestBaseTime()));
        model.setTestBaseTimeFormat(getTestBaseTimeFormat());
        model.setTestInterval(getTestInterval());
        model.setLastTestDateTime(getLastTestDateTime());
        model.setNextTestDateTime(getNextTestDateTime());
        model.setWasLastTestPositive(wasLastTestPositive());
        return model;
    }

    public String toString()
    {
        String s = "Test Num: " + __testNum + "\n" + "Expression Num: " + __dataTestExpressionNum + "\n" + "Group Num: " + __dataTestGroupNum + "\n" + "Status Num: " + __dataTestStatusNum + "\n" + "Active Season Start: '" + __activeSeasonStart + "'\n" + "Active Season End: '" + __activeSeasonEnd + "'\n" + "Description: '" + __description + "'\n" + "IsActive: " + __isActive + "\n" + "Message: '" + __message + "'\n";
        if(__properties != null)
            s = s + "Properties: '" + __properties.toString(";") + "\n";
        else
            s = s + "Properties: '[null]'\n";
        s = s + "Positive Count: " + __positiveCount + "\n" + "Evaluation Interval: " + __evaluationInterval + "\n" + "Evaluation Window: " + __evaluationWindow + "\n" + "Positive Test Interval: " + __positiveTestInterval + "\n" + "Test Base Time: " + __testBaseTime + "\n" + "Test Interval: " + __testInterval + "\n";
        return s;
    }

    public void transferValuesFromDataModel(DataTestDataModel model)
        throws Exception
    {
        if(!model.checkAllSet())
            throw new Exception("Not all data values were read in and set in the data model: " + model.getMissingValues());
        setActionNums(model.getActionNums());
        setActiveSeasonFormat(model.getActiveSeasonFormat());
        if(getActiveSeasonFormat() != null)
        {
            setActiveSeasonEnd(getActiveSeasonFormat().parse(model.getActiveSeasonEndString()));
            setActiveSeasonStart(getActiveSeasonFormat().parse(model.getActiveSeasonStartString()));
        }
        setDataTestExpressionNum(model.getDataTestExpressionNum());
        setDataTestGroupNum(model.getDataTestGroupNum());
        setDataTestStatusNum(model.getDataTestStatusNum());
        setDescription(model.getDescription());
        setEvaluationEnd(model.getEvaluationEnd());
        setEvaluationStart(model.getEvaluationStart());
        setEvaluationInterval(model.getEvaluationInterval());
        setEvaluationWindow(model.getEvaluationWindow());
        setTestNum(model.getTestNum());
        setIsActive(isActive());
        setMessage(model.getMessage());
        setPositiveCount(model.getPositiveCount());
        setPositiveTestInterval(model.getPositiveTestInterval());
        setProperties(model.getProperties());
        setTestBaseTimeFormat(model.getTestBaseTimeFormat());
        if(getTestBaseTimeFormat() != null)
            setTestBaseTime(getTestBaseTimeFormat().parse(model.getTestBaseTimeString()));
        setTestInterval(model.getTestInterval());
    }

    public boolean wasLastTestPositive()
    {
        return __wasLastTestPositive;
    }

    public void postTestRun()
    {
        if(__positiveCount > 1 && __actions != null)
        {
            DataTestResult result = null;
            int count = 0;
            int size1 = 0;
            int size2 = 0;
            Vector results = null;
            Vector v = null;
            for(int i = 0; i < __actions.length; i++)
            {
                results = __actions[i].getPositiveResults();
                size1 = results.size();
label0:
                for(int j = 0; j < size1; j++)
                {
                    v = (Vector)results.elementAt(j);
                    size2 = v.size();
                    int k = 0;
                    do
                    {
                        if(k >= size2)
                            continue label0;
                        result = (DataTestResult)v.elementAt(k);
                        if(result.getDataTest() == this)
                        {
                            count++;
                            continue label0;
                        }
                        k++;
                    } while(true);
                }

            }

            boolean hit = false;
            if(count < __positiveCount)
            {
                for(int i = 0; i < __actions.length; i++)
                {
                    results = __actions[i].getPositiveResults();
                    size1 = results.size();
                    for(int j = size1 - 1; j >= 0; j--)
                    {
                        hit = false;
                        v = (Vector)results.elementAt(j);
                        size2 = v.size();
                        for(int k = 0; k < size2; k++)
                        {
                            result = (DataTestResult)v.elementAt(k);
                            if(result.getDataTest() == this)
                                hit = true;
                        }

                        if(hit)
                            results.removeElementAt(j);
                    }

                }

            }
        }
        if(__positiveCount > 1 && __results.size() < __positiveCount)
            __results.removeAllElements();
    }

    public void preTestRun()
    {
        __results.removeAllElements();
        __wasLastTestPositive = false;
    }

    public int getPositiveResultsCount()
    {
        return __results.size();
    }

    public DateTime trimToActiveSeasonStart(DateTime date)
    {
        if(__activeSeasonStart == null)
            return date;
        __activeSeasonFormat.fillRelativeDateTime(__activeSeasonStart, date);
        if(__activeSeasonStart.lessThanOrEqualTo(date))
            return date;
        else
            return new DateTime(__activeSeasonStart);
    }

    public DateTime trimToActiveSeasonEnd(DateTime date)
    {
        if(__activeSeasonEnd == null)
            return date;
        __activeSeasonFormat.fillRelativeDateTime(__activeSeasonEnd, date);
        if(__activeSeasonEnd.greaterThanOrEqualTo(date))
            return date;
        else
            return new DateTime(__activeSeasonEnd);
    }

    public boolean computeNextRunDate(DateTime currentDate)
    {
        DateTime next = new DateTime(currentDate);
        int positiveCount = getPositiveResultsCount();
        if(positiveCount > 0 && getPositiveTestInterval() != null)
            next.addInterval(getPositiveTestInterval().getBase(), getPositiveTestInterval().getMultiplier());
        else
            next.addInterval(getTestInterval().getBase(), getTestInterval().getMultiplier());
        if(positiveCount > 0)
            setWasLastTestPositive(true);
        DateTime testBaseTime = new DateTime(getTestBaseTime());
        DateTimeFormat format = getTestBaseTimeFormat();
        format.fillRelativeDateTime(testBaseTime, next);
        if(next.greaterThan(testBaseTime) && testBaseTime.greaterThan(currentDate))
            setNextTestDateTime(testBaseTime);
        else
            setNextTestDateTime(next);
        return true;
    }

    private Action __actions[];
    private boolean __isActive;
    private boolean __isMaster;
    private boolean __wasLastTestPositive;
    private DataTestExpression __expression;
    private DateTime __activeSeasonEnd;
    private DateTime __activeSeasonStart;
    private DateTime __evaluationEnd;
    private DateTime __evaluationStart;
    private DateTime __lastTestDateTime;
    private DateTime __nextTestDateTime;
    private DateTime __testBaseTime;
    private DateTimeFormat __activeSeasonFormat;
    private DateTimeFormat __testBaseTimeFormat;
    private int __actionNums[];
    private int __dataTestExpressionNum;
    private int __dataTestGroupNum;
    private int __dataTestStatusNum;
    private int __testNum;
    private int __positiveCount;
    private String __description;
    private String __id;
    private String __message;
    private PropList __properties;
    private TimeInterval __evaluationInterval;
    private TimeInterval __evaluationWindow;
    private TimeInterval __positiveTestInterval;
    private TimeInterval __testInterval;
    private Vector __dataTests;
    private Vector __results;
}